<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>内联(inline)函数</title>
    <url>/%E7%AC%94%E8%AE%B0/%E5%86%85%E8%81%94-inline-%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<p>inline是C++关键字，在函数声明或定义中，函数返回类型前加上关键字inline，即可以把函数指定为内联函数。</p>
<a id="more"></a>

<p>在c/c++中，为了解决一些频繁调用的小函数大量消耗栈空间的问题，特别的引入了inline修饰符，表示为内联函数。内联函数实质是在调用点将函数展开，从而减少了对堆栈的操作（在堆栈中调用函数较为复杂，直接展开为代码运行效率更高）。</p>
<p>内联函数牺牲了空间但是降低了调用函数时的额外开销，以空间换时间，在大部分情况下时值得的。</p>
<h3 id="内联函数的使用方法"><a href="#内联函数的使用方法" class="headerlink" title="内联函数的使用方法"></a>内联函数的使用方法</h3><p>在class之外，多一个inline修饰符。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class A&#123;</span><br><span class="line">private:</span><br><span class="line">    &#x2F;*...*&#x2F;</span><br><span class="line">public:</span><br><span class="line">    &#x2F;*...*&#x2F;</span><br><span class="line">    int add(int x,int y) &#123;return x+y;&#125;    </span><br><span class="line">    &#x2F;*...*&#x2F;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;*</span><br><span class="line">如果在类中未给出成员函数定义，而又想内联该函数的话，那在类外要加上inline，否则就认为不是内联的</span><br><span class="line">*&#x2F;</span><br><span class="line">inline int A::add(int x,int y)&#123;</span><br><span class="line">    &#x2F;*...*&#x2F;</span><br><span class="line">&#125;</span><br><span class="line">inline int add1(int x,int y)&#123;</span><br><span class="line">    &#x2F;*...*&#x2F;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在class之内定义的函数是自动内联的。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class A&#123;</span><br><span class="line">private:</span><br><span class="line">    &#x2F;*...*&#x2F;</span><br><span class="line">public:</span><br><span class="line">    &#x2F;*...*&#x2F;</span><br><span class="line">    int add(int x,int y) &#123;return x+y;&#125;    </span><br><span class="line">    &#x2F;*...*&#x2F;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="内联函数的使用规则"><a href="#内联函数的使用规则" class="headerlink" title="内联函数的使用规则"></a>内联函数的使用规则</h3><ol>
<li><p>inline说明对编译器来说只是一种建议，编译器可以选择忽略这个建议。对于过大的函数，编译器会忽略inline。</p>
</li>
<li><p>关键字inline 必须与<strong>函数定义体放在一起</strong>才能使函数成为内联，仅将inline 放在函数声明前面<strong>不起任何作用</strong>,inline函数实质上是一种<strong>声明</strong>，最好直接将内联函数定义一起放在.h文件中。</p>
</li>
</ol>
<h3 id="使用inline的时机"><a href="#使用inline的时机" class="headerlink" title="使用inline的时机"></a>使用inline的时机</h3><p>代码短小（例如只有2、3行）且多次调用。</p>
<p>若函数较大或有递归调用(Recursive functions)则不使用inline。</p>
<h3 id="inline函数与宏函数的差异"><a href="#inline函数与宏函数的差异" class="headerlink" title="inline函数与宏函数的差异"></a>inline函数与宏函数的差异</h3><p>宏</p>
<ol>
<li><p>宏调用是通过简单文本替换来实现的，不会对参数进行类型检查。</p>
</li>
<li><p>宏的使用是预处理器直接对宏代码进行调用，没有参数压栈、生成相应汇编代码、返回参数等时间花费。</p>
</li>
<li><p>宏可能会产生意想不到的边缘效应，很容易出错，要非常小心优先级的变动。</p>
</li>
</ol>
<p>内联</p>
<ol>
<li><p>inline 对编译器来说是一种请求，而不是命令。</p>
</li>
<li><p>C++中的内联机制既具备宏代码的效率，又增加了安全性，可以自由操作类的数据成员，而宏代码无法操作类的私有成员。</p>
</li>
</ol>
<p>例如对于下面代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#define add1(x,y)	((x)+(y)) &#x2F;&#x2F;宏定义</span><br><span class="line">using namespace std;</span><br><span class="line">inline int add2(int x,int y)&#123; &#x2F;&#x2F;内联</span><br><span class="line">	return x+y;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	double a&#x3D;1.0,b&#x3D;2.0;</span><br><span class="line">	printf(&quot; %d \n&quot;,add1(a,b));</span><br><span class="line">	printf(&quot; %d \n&quot;,add2(a,b));</span><br><span class="line">return 0 ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>得到结果</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0&#x2F;&#x2F;宏没有对类型检测</span><br><span class="line">3&#x2F;&#x2F;inline进行了强制类型转化</span><br></pre></td></tr></table></figure>
<p>因而建议在c++中用inline函数代替宏函数</p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>语法</tag>
      </tags>
  </entry>
  <entry>
    <title>c++中的new和delete</title>
    <url>/%E7%AC%94%E8%AE%B0/c++%E4%B8%AD%E7%9A%84new%E5%92%8Cdelete/</url>
    <content><![CDATA[<p>在c++中堆内存的分配与释放是通过new和delete来实现的，new和delete是两个操作符，无需头文件支持</p>
<a id="more"></a>
<h2 id="new"><a href="#new" class="headerlink" title="new"></a>new</h2><h3 id="new运算符"><a href="#new运算符" class="headerlink" title="new运算符"></a>new运算符</h3><p>new运算符返回指向所分配类型对象的指针，new运算符首先<strong>向系统堆区申请足够的储存空间</strong>，如果申请成功，则再<strong>调用相应的默认构造函数</strong>，然后返回申请空间的地址</p>
<h3 id="new的使用方法"><a href="#new的使用方法" class="headerlink" title="new的使用方法"></a>new的使用方法</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int *p&#x3D; new int ;&#x2F;&#x2F;申请int</span><br><span class="line">int *psome&#x3D; new int[10];&#x2F;&#x2F;申请int数组</span><br><span class="line">A *q&#x3D; new A;&#x2F;&#x2F;申请自定义类型</span><br><span class="line">A *qsome&#x3D; new A[10];&#x2F;&#x2F;申请自定义类型数组</span><br></pre></td></tr></table></figure>
<h2 id="delete"><a href="#delete" class="headerlink" title="delete"></a>delete</h2><h3 id="delete运算符"><a href="#delete运算符" class="headerlink" title="delete运算符"></a>delete运算符</h3><p>delete运算符首先<strong>执行默认析构函数</strong>，然后再<strong>回收分配的空间</strong></p>
<h3 id="delete的使用方法"><a href="#delete的使用方法" class="headerlink" title="delete的使用方法"></a>delete的使用方法</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">delete p;&#x2F;&#x2F;释放int</span><br><span class="line">delete []psome;&#x2F;&#x2F;释放int数组</span><br><span class="line">delete q;&#x2F;&#x2F;释放自定义类型</span><br><span class="line">delete []qsome;&#x2F;&#x2F;释放自定义类型数组</span><br></pre></td></tr></table></figure>
<h3 id="关于delete-ptr和delete-ptr的差别"><a href="#关于delete-ptr和delete-ptr的差别" class="headerlink" title="关于delete ptr和delete []ptr的差别"></a>关于delete ptr和delete []ptr的差别</h3><p>回归到new和delete上，当我们调用operator new[]/new来分配数组对象时，编译器时系统内部会增加4或者8字节的分配空间用来保存所分配的数组对象的数量,可以理解为下面这对pair<br>| 储存分配空间的字节数 | 分配空间的地址 |<br>| -|-|<br>|           4|0xabcd<br>例如分配以下空间</p>
<p><code>A *psome =new A[10];</code></p>
<p>此时如果使用delete psome,则只会调用一次析构函数，但是会收回所有分配的空间；而使用delete []psome，则会依次调用psome[0]-psome[9]的析构函数，然后再收回所有的分配空间</p>
<p>例如对于下面的代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int count&#x3D;0;</span><br><span class="line">class A&#123;</span><br><span class="line">public:</span><br><span class="line">	int i;</span><br><span class="line">	A();</span><br><span class="line">	~A(); </span><br><span class="line">&#125;; </span><br><span class="line">A::A()&#123;&#x2F;&#x2F;构造函数</span><br><span class="line">	i&#x3D;count++;</span><br><span class="line">	cout&lt;&lt;&quot;A::A() i&#x3D;&quot;&lt;&lt;i&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">A::~A()&#123;&#x2F;&#x2F;析构函数</span><br><span class="line">	cout&lt;&lt;&quot;A::~A() i&#x3D;&quot;&lt;&lt;i&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	A *psome&#x3D; new A[10];</span><br><span class="line">	delete psome;</span><br><span class="line">	&#x2F;&#x2F;delete []psome;</span><br><span class="line">    return 0 ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行得到结果如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">A::A() i&#x3D;0&#x2F;&#x2F;依次执行构造函数</span><br><span class="line">A::A() i&#x3D;1</span><br><span class="line">A::A() i&#x3D;2</span><br><span class="line">A::A() i&#x3D;3</span><br><span class="line">A::A() i&#x3D;4</span><br><span class="line">A::A() i&#x3D;5</span><br><span class="line">A::A() i&#x3D;6</span><br><span class="line">A::A() i&#x3D;7</span><br><span class="line">A::A() i&#x3D;8</span><br><span class="line">A::A() i&#x3D;9</span><br><span class="line">A::~A() i&#x3D;0&#x2F;&#x2F;只执行依次析构函数，但空间全部回收</span><br></pre></td></tr></table></figure>
<p>可以看到只执行了依次析构函数，因为对于delete而言psome所指对象只有一个对象</p>
<p>如果执行的是delete []psome,得到结果如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">A::A() i&#x3D;0</span><br><span class="line">A::A() i&#x3D;1</span><br><span class="line">A::A() i&#x3D;2</span><br><span class="line">A::A() i&#x3D;3</span><br><span class="line">A::A() i&#x3D;4</span><br><span class="line">A::A() i&#x3D;5</span><br><span class="line">A::A() i&#x3D;6</span><br><span class="line">A::A() i&#x3D;7</span><br><span class="line">A::A() i&#x3D;8</span><br><span class="line">A::A() i&#x3D;9&#x2F;&#x2F;执行10次构造函数</span><br><span class="line">A::~A() i&#x3D;9</span><br><span class="line">A::~A() i&#x3D;8</span><br><span class="line">A::~A() i&#x3D;7</span><br><span class="line">A::~A() i&#x3D;6</span><br><span class="line">A::~A() i&#x3D;5</span><br><span class="line">A::~A() i&#x3D;4</span><br><span class="line">A::~A() i&#x3D;3</span><br><span class="line">A::~A() i&#x3D;2</span><br><span class="line">A::~A() i&#x3D;1</span><br><span class="line">A::~A() i&#x3D;0&#x2F;&#x2F;执行10次析构函数</span><br></pre></td></tr></table></figure>
<p>可以看到执行了10次析构函数，并且是从最后一个元素开始向前执行的，此时delete知道psome所指地址有多个对象，会通过上面的pair计算要执行析构函数的次数并依次执行</p>
<p>因此就结论而言，new/delete 、new []/delete[] 最好要配对使用</p>
<h2 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h2><p>1.不要使用delete去释放没有new的内存</p>
<p>2.不要重复delete</p>
<p>3.delete[]和new[]配套使用 ，delete和new配套使用</p>
<p>4.delete空指针是安全的（体现完备性）</p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>语法</tag>
      </tags>
  </entry>
  <entry>
    <title>markdown基本语法</title>
    <url>/%E7%AC%94%E8%AE%B0/%E6%B5%8B%E8%AF%95%E6%96%87%E7%AB%A0/</url>
    <content><![CDATA[<p>用于练习markdown语法与相关操作</p>
<a id="more"></a>
<h2 id="0-让文字显示摘要"><a href="#0-让文字显示摘要" class="headerlink" title="0.让文字显示摘要"></a>0.让文字显示摘要</h2><p>在MD格式文章正文插入&lt;!-- more --&gt;即可，这样只会显示之前的内容</p>
<h2 id="1-标题控制"><a href="#1-标题控制" class="headerlink" title="1.标题控制"></a>1.标题控制</h2><p>利用#号控制标题</p>
<p>1.#一级标题</p>
<h1 id="一级标题"><a href="#一级标题" class="headerlink" title="一级标题"></a>一级标题</h1><p>2.##二级标题  </p>
<h2 id="二级标题"><a href="#二级标题" class="headerlink" title="二级标题"></a>二级标题</h2><p>3.###三级标题  </p>
<h3 id="三级标题"><a href="#三级标题" class="headerlink" title="三级标题"></a>三级标题</h3><p>4.####四级标题  </p>
<h4 id="四级标题"><a href="#四级标题" class="headerlink" title="四级标题"></a>四级标题</h4><p>5.#####五级标题  </p>
<h5 id="五级标题"><a href="#五级标题" class="headerlink" title="五级标题"></a>五级标题</h5><p>6.######六级标题</p>
<h6 id="六级标题"><a href="#六级标题" class="headerlink" title="六级标题"></a>六级标题</h6><h2 id="2-段落分行"><a href="#2-段落分行" class="headerlink" title="2.段落分行"></a>2.段落分行</h2><p>只需要在两个段落间加一个空行，即回车两次</p>
<h2 id="3-区块引用"><a href="#3-区块引用" class="headerlink" title="3.区块引用"></a>3.区块引用</h2><blockquote>
<p>在引用的区块前加’&gt;’即可</p>
</blockquote>
<h2 id="4-超链接"><a href="#4-超链接" class="headerlink" title="4.超链接"></a>4.超链接</h2><p>[超链接显示文字](<a href="http://www.baidu.com" target="_blank" rel="noopener">http://www.baidu.com</a> “超链接title”)</p>
<p><a href="http://www.baidu.com" target="_blank" rel="noopener" title="超链接title">超链接显示文字</a></p>
<p>其中超链接title为浮动提示文字，懒狗不写</p>
<h2 id="5-图片显示"><a href="#5-图片显示" class="headerlink" title="5.图片显示"></a>5.图片显示</h2><p>![百度logo](<a href="https://www.baidu.com/img/bd_logo1.png?where=super" target="_blank" rel="noopener">https://www.baidu.com/img/bd_logo1.png?where=super</a>)</p>
<p><img src="https://www.baidu.com/img/bd_logo1.png?where=super" alt="百度logo"></p>
<h2 id="6-无序列表"><a href="#6-无序列表" class="headerlink" title="6.无序列表"></a>6.无序列表</h2><p>无序列表使用<em>、+、-标识，但是一般使用</em>来标识无序列表</p>
<p>* 无序列表</p>
<p>+ 无序列表</p>
<p>- 无序列表</p>
<p>显示</p>
<ul>
<li>无序列表</li>
</ul>
<ul>
<li>无序列表</li>
</ul>
<ul>
<li>无序列表<h2 id="7-有序列表"><a href="#7-有序列表" class="headerlink" title="7.有序列表"></a>7.有序列表</h2>用数字 + ‘.’ 标识</li>
</ul>
<p>1.有序列表1</p>
<p>   1.有序列表2</p>
<p>2.有序列表3</p>
<p>显示为</p>
<ol>
<li>有序列表1<ol>
<li>有序列表2</li>
</ol>
</li>
<li>有序列表3    </li>
</ol>
<h2 id="8-分隔线"><a href="#8-分隔线" class="headerlink" title="8.分隔线"></a>8.分隔线</h2><p>***</p>
<p>显示如下</p>
<hr>
<h2 id="9-字体修改"><a href="#9-字体修改" class="headerlink" title="9.字体修改"></a>9.字体修改</h2><p>*斜体*</p>
<p><em>斜体</em></p>
<p>**加粗**</p>
<p><strong>加粗</strong></p>
<p>***斜体加粗***</p>
<p><strong><em>斜体加粗</em></strong></p>
<h2 id="10-代码块"><a href="#10-代码块" class="headerlink" title="10.代码块"></a>10.代码块</h2><p>利用单个反引号`（在esc下面） 包裹代码</p>
<p>`int a=1 `</p>
<p><code>int a=1</code></p>
<p>处理多行代码是通过三个反引号包裹代码</p>
<p>```</p>
<p> int a=1;</p>
<p> int b=2;</p>
<p> int c=3;</p>
<p>```</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">int a&#x3D;1;</span><br><span class="line">int b&#x3D;2;</span><br><span class="line">int c&#x3D;3;</span><br></pre></td></tr></table></figure>

<h2 id="11-表格"><a href="#11-表格" class="headerlink" title="11.表格"></a>11.表格</h2><p>| a | b | c |</p>
<p>|—|—|—|</p>
<p>|1  |2  |3  |</p>
<p>|4  |5  |6  |</p>
<p>|7  |8  |9  |</p>
<table>
<thead>
<tr>
<th>a</th>
<th>b</th>
<th>c</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>2</td>
<td>3</td>
</tr>
<tr>
<td>4</td>
<td>5</td>
<td>6</td>
</tr>
<tr>
<td>7</td>
<td>8</td>
<td>9</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>语法</tag>
        <tag>markdown</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/%E9%9A%8F%E7%AC%94/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<a id="more"></a>

<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>Hello World</tag>
      </tags>
  </entry>
</search>
