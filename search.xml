<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>高级搜索树-伸展树(Splay Tree)</title>
    <url>/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%AB%98%E7%BA%A7%E6%90%9C%E7%B4%A2%E6%A0%91-%E4%BC%B8%E5%B1%95%E6%A0%91SplayTree/</url>
    <content><![CDATA[<p>与AVL树一样，伸展树(Splay Tree)也是平衡二叉搜索树的一致，伸展树无需时刻都严格保持整棵树的平衡，也不需要对基本的二叉树结点做任何附加改动，能够保持分摊意义下的高效率。</p>
<a id="more"></a>
<h3 id="局部性"><a href="#局部性" class="headerlink" title="局部性"></a>局部性</h3><p>通常在任意数据结构的生命期内，执行不同操作的概率往往极不均衡，且各操作之间具有极强的关联性，比如<strong>数据局部性</strong>，所谓数据局部性包括：</p>
<ol>
<li><p>刚刚被访问到的元素，很可能不久之后就再次被访问</p>
</li>
<li><p>将被访问的下一元素，很可能就处于不久之前被访问够的某个元素的附近<br>故每次都只需将刚被访问到的节点及时地转移到树根（附近），即可加速后续的操作，转移操作与AVL树的旋转操作类似</p>
<h3 id="双层伸展"><a href="#双层伸展" class="headerlink" title="双层伸展"></a>双层伸展</h3><p>每次都从当前节点v向上追溯两层，并根据其父亲p和祖父g的相对位置进行相应的旋转</p>
</li>
<li><p>zig-zig/zag-zag</p>
</li>
</ol>
<p><img src="../_posts/picture/zig-zig.png" alt="zig-zig操作"></p>
<ol start="2">
<li>zig-zag/zag-zig</li>
</ol>
<p><img src="../_posts/picture/zig-zag.png" alt="zig-zag操作"></p>
<ol start="3">
<li>zig/zag(若深度为奇数，需要额外执行一次zig/zag操作)</li>
</ol>
<p><img src="../_posts/picture/zig.png" alt="zig/zag操作"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&#x2F;&#x2F;	从节点v开始逐层进行伸展</span><br><span class="line">template&lt;typename T&gt;</span><br><span class="line">inline SplayNodePos(T) SplayTree&lt;T&gt;::splay(SplayNodePos(T)	&amp; v) &#123;&#x2F;&#x2F;v为因最近访问而需要伸展的节点</span><br><span class="line">	if (!v)		return	NULL;</span><br><span class="line">	SplayNodePos(T)	p &#x3D; NULL;</span><br><span class="line">	SplayNodePos(T) g &#x3D; NULL;	&#x2F;&#x2F;v的父亲以及祖父</span><br><span class="line">	while ((p &#x3D; v-&gt;pa) &amp;&amp; (g &#x3D; p-&gt;pa)	)&#123;&#x2F;&#x2F;	p、g均存在，可以做双层伸展</span><br><span class="line">		SplayNodePos(T)	gg &#x3D; g-&gt;pa;	&#x2F;&#x2F;gg为v的曾祖父</span><br><span class="line">		if (IsLChild(v) &amp;&amp; IsLChild(p)) &#123;</span><br><span class="line">			attachAsLChild(p, v-&gt;rc);</span><br><span class="line">			attachAsLChild(g, p-&gt;rc);</span><br><span class="line">			attachAsRChild(v, p);</span><br><span class="line">			attachAsRChild(p, g);</span><br><span class="line">		&#125;</span><br><span class="line">		else if (IsRChild(v) &amp;&amp; IsRChild(p) )&#123;</span><br><span class="line">			attachAsRChild(p, v-&gt;lc);</span><br><span class="line">			attachAsRChild(g, p-&gt;lc);</span><br><span class="line">			attachAsLChild(v, p);</span><br><span class="line">			attachAsLChild(p, g);</span><br><span class="line">		&#125;</span><br><span class="line">		else if (IsLChild(v) &amp;&amp; IsRChild(p)) &#123;</span><br><span class="line">			attachAsRChild(g,v-&gt;lc);</span><br><span class="line">			attachAsLChild(p,v-&gt;rc);</span><br><span class="line">			attachAsRChild(v,p);</span><br><span class="line">			attachAsLChild(v,g);</span><br><span class="line">		&#125;</span><br><span class="line">		else if (IsRChild(v) &amp;&amp; IsLChild(p)) &#123;</span><br><span class="line">			attachAsLChild(g, v-&gt;rc);</span><br><span class="line">			attachAsRChild(g, v-&gt;lc);</span><br><span class="line">			attachAsLChild(v, p);</span><br><span class="line">			attachAsRChild(v, g);</span><br><span class="line">		&#125;</span><br><span class="line">		if (!gg)	v-&gt;pa &#x3D; NULL;		&#x2F;&#x2F;如果v的曾祖父gg不存在，则v现在是root</span><br><span class="line">		else	&#x2F;&#x2F;否则将v接到gg上</span><br><span class="line">			(g &#x3D;&#x3D; gg-&gt;lc)? attachAsLChild(gg, v) :attachAsRChild(gg, v);</span><br><span class="line">	&#125;	&#x2F;&#x2F;双层伸展结束，必有g&#x3D;&#x3D;NULL,但是p可能非空</span><br><span class="line">	if (p &#x3D; v-&gt;pa) &#123;		&#x2F;&#x2F;若p非空，再单独做一次单选</span><br><span class="line">		if (IsLChild(v)) &#123;</span><br><span class="line">			attachAsLChild(p, v-&gt;rc);</span><br><span class="line">			attachAsRChild(v,p);</span><br><span class="line">		&#125;</span><br><span class="line">		else &#123;</span><br><span class="line">			attachAsRChild(p, v-&gt;lc);</span><br><span class="line">			attachAsLChild(v, p);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	v-&gt;pa &#x3D; NULL;</span><br><span class="line">	return v;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="查找操作"><a href="#查找操作" class="headerlink" title="查找操作"></a>查找操作</h3><p>不同于其他平衡二叉搜索树的查找操作，伸展树的查找操作是一个动态操作，每次查找后要将最后一个访问的节点通过伸展操作splay到树根</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;查找函数，若存在值为key的节点返回相应节点，若不存在则返回相应父节点</span><br><span class="line">template&lt;typename T&gt;</span><br><span class="line">inline SplayNodePos(T) SplayTree&lt;T&gt;::search(const T &amp; key)</span><br><span class="line">&#123;</span><br><span class="line">	SplayNodePos(T) hot &#x3D; NULL;&#x2F;&#x2F;hot为返回节点的父节点</span><br><span class="line">	SplayNodePos(T) x&#x3D;  searchIn(key, root, hot);</span><br><span class="line">	if (x)</span><br><span class="line">		root &#x3D; splay(x);</span><br><span class="line">	else</span><br><span class="line">		root &#x3D; splay(hot);</span><br><span class="line">	return root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="插入操作"><a href="#插入操作" class="headerlink" title="插入操作"></a>插入操作</h3><p><img src="../_posts/picture/insert.png" alt="插入操作"></p>
<p>先利用search操作，注意search此时是一个动态操作，会将最后访问的节点t通过splay操作提升为树根，此时有如上图我们新建节点v并将其作为根接入原树，以t为左子，t的右子为其右子</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&#x2F;&#x2F;插入值为key的节点</span><br><span class="line">template&lt;typename T&gt;</span><br><span class="line">SplayNodePos(T) SplayTree&lt;T&gt;::insert(const T &amp; key)</span><br><span class="line">&#123;</span><br><span class="line">	if (!root)&#x2F;&#x2F;原树为空</span><br><span class="line">		return root &#x3D; new SplayNode&lt;T&gt;(key);</span><br><span class="line">	if (key &#x3D;&#x3D; search(key)-&gt;key)	&#x2F;&#x2F;存在值为key的节点，无需执行插入操作，且查找时已经执行了splay操作，此时root为值为key的节点</span><br><span class="line">		return root;</span><br><span class="line">	&#x2F;&#x2F;目标节点不存在</span><br><span class="line">	SplayNodePos(T) t&#x3D; root;</span><br><span class="line">	if (root-&gt;key &lt; key) &#123;	&#x2F;&#x2F;插入新根，分别以t和t-&gt;rc为左右孩子</span><br><span class="line">		t-&gt;pa &#x3D; root &#x3D; new SplayNode&lt;T&gt;(key, NULL, t, t-&gt;rc);</span><br><span class="line">		if (HasRChild(t)) &#123;</span><br><span class="line">			t-&gt;rc-&gt;pa &#x3D; root;</span><br><span class="line">			t-&gt;rc &#x3D; NULL; </span><br><span class="line">		&#125;</span><br><span class="line">	&#125;else &#123;&#x2F;&#x2F;插入新根，分别以t-&gt;lc和t为左右孩子</span><br><span class="line">		t-&gt;pa &#x3D; root &#x3D; new SplayNode&lt;T&gt;(key, NULL, t-&gt;lc, t);</span><br><span class="line">		if (HasLChild(t)) &#123;</span><br><span class="line">			t-&gt;lc-&gt;pa &#x3D; root;</span><br><span class="line">			t-&gt;lc &#x3D; NULL; </span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return root;</span><br><span class="line">&#125;	&#x2F;&#x2F;无论key是否存在于原树中，返回时总有root-&gt;key &#x3D;&#x3D; key</span><br></pre></td></tr></table></figure>

<h3 id="删除操作"><a href="#删除操作" class="headerlink" title="删除操作"></a>删除操作</h3><p><img src="../_posts/picture/remove.png" alt="删除操作"></p>
<p>先利用search操作，注意search此时是一个动态操作，会将最后访问的节点v通过splay操作伸展为树根，如果要删除的节点存在于树中，则此时通过splay操作伸展为树根，我们不妨先将root的左右子树先分开，利用search和splay操作将右子树的值最小的节点伸展至树根，此时root必定没有左子树，再将原左子树接回新树，得到最终的树</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&#x2F;&#x2F;删除值为key的节点</span><br><span class="line">template&lt;typename T&gt;</span><br><span class="line">inline bool SplayTree&lt;T&gt;::remove(const T &amp; key)</span><br><span class="line">&#123;</span><br><span class="line">	if (!root || key !&#x3D; search(key)-&gt;key)	&#x2F;&#x2F;若原树为空或目标不存在则不执行删除操作</span><br><span class="line">		return false;		</span><br><span class="line">	SplayNodePos(T)		t &#x3D; root;</span><br><span class="line">	&#x2F;&#x2F;注意上面执行了search操作，即此时已经伸展过原树，有root-&gt;key &#x3D;&#x3D; key</span><br><span class="line">	if (!HasLChild(root)) &#123;	&#x2F;&#x2F;若无左子树，直接删除根节点</span><br><span class="line">		root &#x3D; root-&gt;rc;</span><br><span class="line">		if (root-&gt;rc)</span><br><span class="line">			root-&gt;rc-&gt;pa &#x3D; NULL;</span><br><span class="line">	&#125;</span><br><span class="line">	else if (!HasRChild(root)) &#123;	&#x2F;&#x2F;若无右子树，直接删除根节点</span><br><span class="line">		root &#x3D; root-&gt;lc;</span><br><span class="line">		if (root-&gt;lc)</span><br><span class="line">			root-&gt;lc-&gt;pa &#x3D; NULL;</span><br><span class="line">	&#125;else &#123;	&#x2F;&#x2F;否则左右子树均存在，此时</span><br><span class="line">		SplayNodePos(T)		ltree &#x3D; root-&gt;lc;</span><br><span class="line">		ltree-&gt;pa &#x3D; NULL;	root-&gt;lc &#x3D; NULL;	&#x2F;&#x2F;暂时切除左子树</span><br><span class="line">		root &#x3D; root-&gt;rc; root-&gt;pa &#x3D; NULL;&#x2F;&#x2F;将删除节点和右子树分离</span><br><span class="line">		search(key);	&#x2F;&#x2F;再执行一次search操作，此时左侧key最小的节点会伸展至root，且root无左子树</span><br><span class="line">		root-&gt;lc &#x3D; ltree;	ltree-&gt;pa &#x3D; root;	&#x2F;&#x2F;将原左子树接回整树中</span><br><span class="line">	&#125;</span><br><span class="line">	delete t;	&#x2F;&#x2F;删除原根节点</span><br><span class="line">	return true;	&#x2F;&#x2F;成功删除</span><br><span class="line">&#125;</span><br><span class="line">#endif &#x2F;&#x2F; ! _SPLAYTREE_DECLARATION_H</span><br></pre></td></tr></table></figure>

<h3 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a>性能分析</h3><p>利用双层伸展，即使是单链的最坏情况，最终也可以将其压缩至长度大致折半，故即使每次都访问最深处节点，最坏情况也不会持续发生。伸展树虽然不能杜绝最坏情况的发生，但是却能有效地控制最坏情况发生的频度，从而保证分摊意义下的整体高效。利用势能分析法可以证明伸展树的到此操作均可在分摊的O(log n)的时间内完成。</p>
<h3 id="完整源码"><a href="#完整源码" class="headerlink" title="完整源码"></a>完整源码</h3><p>“SplayTree_Define.h”</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">#ifndef _SPLAYTREE_DEFINE_H</span><br><span class="line">#define _SPLAYTREE_DEFINE_H</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;#include&quot;pch.h&quot;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#define SplayNodePos(T)	SplayNode&lt;T&gt; *</span><br><span class="line">&#x2F;&#x2F;宏定义</span><br><span class="line">#define IsRoot(x)		( !((x)-&gt;pa) )</span><br><span class="line">#define IsLChild(x)	( !(IsRoot(x)	) &amp;&amp; (x)&#x3D;&#x3D;(x)-&gt;pa-&gt;lc)</span><br><span class="line">#define IsRChild(x)	( !(IsRoot(x)	) &amp;&amp; (x)&#x3D;&#x3D;(x)-&gt;pa-&gt;rc)</span><br><span class="line">#define HasLChild(x)	((x)-&gt;lc )</span><br><span class="line">#define HasRChild(x)	((x)-&gt;rc )</span><br><span class="line">#define HasChild(x)		(HasLChild(x) || HasRChild(x))</span><br><span class="line">#define HasBothChild(x)	(HasRChild(x) &amp;&amp; HasLChild(x) )</span><br><span class="line">#define IsLeaf(x)		(! HasChild(x) )</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;SplayNode 定义</span><br><span class="line">template&lt;typename T&gt;</span><br><span class="line">struct SplayNode &#123;</span><br><span class="line">public:</span><br><span class="line">	T key;</span><br><span class="line">	SplayNodePos(T) pa;&#x2F;&#x2F;pa -- parent</span><br><span class="line">	SplayNodePos(T)  lc;&#x2F;&#x2F;lc -- left child</span><br><span class="line">	SplayNodePos(T)  rc;&#x2F;&#x2F;rc -- right child</span><br><span class="line">	&#x2F;&#x2F;构造函数</span><br><span class="line">	SplayNode() :pa(NULL), lc(NULL), rc(NULL) &#123;&#125;</span><br><span class="line">	SplayNode(T elem, SplayNodePos(T)	 pa &#x3D; NULL, SplayNodePos(T) lc &#x3D; NULL, SplayNodePos(T)	 rc &#x3D; NULL) :</span><br><span class="line">		key(elem),  pa(pa), lc(lc), rc(rc) &#123; &#125;</span><br><span class="line">&#125;;</span><br><span class="line">&#x2F;&#x2F;AVLTree 定义</span><br><span class="line">template&lt;typename T&gt;</span><br><span class="line">class SplayTree &#123;</span><br><span class="line">private:</span><br><span class="line">	SplayNodePos(T)	 root;		&#x2F;&#x2F;树根</span><br><span class="line">public:</span><br><span class="line">	&#x2F;&#x2F;构造函数和析构函数</span><br><span class="line">	SplayTree() :root(NULL) &#123;&#125;</span><br><span class="line">	~SplayTree() &#123;&#125;</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F;只读函数</span><br><span class="line">	int height() &#123; return Height(root); &#125;</span><br><span class="line">	&#x2F;&#x2F;遍历函数</span><br><span class="line">	void preOrder();	&#x2F;&#x2F;前序遍历</span><br><span class="line">	void inOrder();		&#x2F;&#x2F;中序遍历</span><br><span class="line">	void postOrder();	&#x2F;&#x2F;后序遍历</span><br><span class="line">	&#x2F;&#x2F;操作函数</span><br><span class="line">	SplayNodePos(T)	search(const T	 &amp;key);		&#x2F;&#x2F;查找函数，若存在值为key的节点返回相应节点，若不存在则返回NULL，基于searchIn函数实现</span><br><span class="line">	SplayNodePos(T) insert(const T &amp;key);		&#x2F;&#x2F;插入值为key的节点</span><br><span class="line">	bool remove(const T &amp;key);	&#x2F;&#x2F;移除值为key的节点</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">	</span><br><span class="line">	void preOrder(SplayNodePos(T) &amp;cur);		&#x2F;&#x2F;以cur节点为root进行前序遍历</span><br><span class="line">	void inOrder(SplayNodePos(T) &amp;cur);		&#x2F;&#x2F;以cur节点为root进行中序遍历</span><br><span class="line">	void postOrder(SplayNodePos(T) &amp;cur);	&#x2F;&#x2F;以cur节点为root进行后序遍历</span><br><span class="line">	SplayNodePos(T) searchIn(const T &amp; key, SplayNodePos(T) cur, SplayNodePos(T)&amp; hot);	&#x2F;&#x2F;以cur节点为root查找值为key的节点，hot为返回节点的父节点</span><br><span class="line">	SplayNodePos(T) splay(SplayNodePos(T) &amp;cur);		&#x2F;&#x2F;	从节点cur开始逐层进行伸展</span><br><span class="line">&#125;;</span><br><span class="line">template&lt;typename NodePos&gt;</span><br><span class="line">inline void attachAsLChild(NodePos p, NodePos lc);&#x2F;&#x2F;lc作为p的左子接入，lc可能为空</span><br><span class="line">template&lt;typename NodePos&gt;</span><br><span class="line">inline void attachAsRChild(NodePos p, NodePos rc);&#x2F;&#x2F;rc作为p的右子子接入，lc可能为空</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>

<p>“SplayTree_Declaration.h”</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">#include&quot;pch.h&quot;</span><br><span class="line">#ifndef  _SPLAYTREE_DECLARATION_H</span><br><span class="line">#define  _SPLAYTREE_DECLARATION_H</span><br><span class="line"></span><br><span class="line">#include&quot;SplayTree_Declaration.h&quot;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">template&lt;typename T&gt;</span><br><span class="line">inline void SplayTree&lt;T&gt;::preOrder(SplayNodePos(T) &amp; cur)</span><br><span class="line">&#123;</span><br><span class="line">	if (!cur)	return;</span><br><span class="line">	std::cout &lt;&lt; cur-&gt;key &lt;&lt; &quot; &quot;;</span><br><span class="line">	preOrder(cur-&gt;lc);</span><br><span class="line">	preOrder(cur-&gt;rc);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;typename T&gt;</span><br><span class="line">inline void SplayTree&lt;T&gt;::inOrder(SplayNodePos(T) &amp; cur)</span><br><span class="line">&#123;</span><br><span class="line">	if (!cur)	return;</span><br><span class="line">	inOrder(cur-&gt;lc);</span><br><span class="line">	std::cout &lt;&lt; cur-&gt;key &lt;&lt; &quot; &quot;;</span><br><span class="line">	inOrder(cur-&gt;rc);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;typename T&gt;</span><br><span class="line">inline void SplayTree&lt;T&gt;::postOrder(SplayNodePos(T)&amp; cur)</span><br><span class="line">&#123;</span><br><span class="line">	if (!cur)	return;</span><br><span class="line">	postOrder(cur-&gt;lc);</span><br><span class="line">	postOrder(cur-&gt;rc);</span><br><span class="line">	std::cout &lt;&lt; cur-&gt;key &lt;&lt; &quot; &quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;typename T&gt;</span><br><span class="line">inline void SplayTree&lt;T&gt;::preOrder()</span><br><span class="line">&#123;</span><br><span class="line">	preOrder(root);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;typename T&gt;</span><br><span class="line">inline void SplayTree&lt;T&gt;::inOrder()</span><br><span class="line">&#123;</span><br><span class="line">	inOrder(root);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;typename T&gt;</span><br><span class="line">inline void SplayTree&lt;T&gt;::postOrder()</span><br><span class="line">&#123;</span><br><span class="line">	postOrder(root);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;lc作为p的左子接入，lc可能为空</span><br><span class="line">template&lt;typename NodePos&gt;</span><br><span class="line">inline void attachAsLChild(NodePos p, NodePos lc) &#123;	</span><br><span class="line">	p-&gt;lc &#x3D; lc;</span><br><span class="line">	if (lc)	lc-&gt;pa &#x3D; p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;rc作为p的右子子接入，lc可能为空</span><br><span class="line">template&lt;typename NodePos&gt;</span><br><span class="line">inline void attachAsRChild(NodePos p, NodePos rc) &#123;	</span><br><span class="line">	p-&gt;rc &#x3D; rc;</span><br><span class="line">	if (rc)	rc-&gt;pa &#x3D; p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;以cur节点为root查找值为key的节点，hot为返回节点的父节点</span><br><span class="line">template&lt;typename T&gt;</span><br><span class="line">inline SplayNodePos(T) SplayTree&lt;T&gt;::searchIn(const T &amp; key, SplayNodePos(T) cur, SplayNodePos(T)&amp; hot)</span><br><span class="line">&#123;</span><br><span class="line">	if (!cur || key &#x3D;&#x3D; cur-&gt;key)	return cur;</span><br><span class="line">	hot &#x3D; cur;</span><br><span class="line">	return searchIn(key, (key &lt; cur-&gt;key ? cur-&gt;lc : cur-&gt;rc), hot);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;查找函数，若存在值为key的节点返回相应节点，若不存在则返回相应父节点</span><br><span class="line">template&lt;typename T&gt;</span><br><span class="line">inline SplayNodePos(T) SplayTree&lt;T&gt;::search(const T &amp; key)</span><br><span class="line">&#123;</span><br><span class="line">	SplayNodePos(T) hot &#x3D; NULL;&#x2F;&#x2F;hot为返回节点的父节点</span><br><span class="line">	SplayNodePos(T) x&#x3D;  searchIn(key, root, hot);</span><br><span class="line">	if (x)</span><br><span class="line">		root &#x3D; splay(x);</span><br><span class="line">	else</span><br><span class="line">		root &#x3D; splay(hot);</span><br><span class="line">	return root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;插入值为key的节点</span><br><span class="line">template&lt;typename T&gt;</span><br><span class="line">SplayNodePos(T) SplayTree&lt;T&gt;::insert(const T &amp; key)</span><br><span class="line">&#123;</span><br><span class="line">	if (!root)&#x2F;&#x2F;原树为空</span><br><span class="line">		return root &#x3D; new SplayNode&lt;T&gt;(key);</span><br><span class="line">	if (key &#x3D;&#x3D; search(key)-&gt;key)	&#x2F;&#x2F;存在值为key的节点，无需执行插入操作，且查找时已经执行了splay操作，此时root为值为key的节点</span><br><span class="line">		return root;</span><br><span class="line">	&#x2F;&#x2F;目标节点不存在</span><br><span class="line">	SplayNodePos(T) t&#x3D; root;</span><br><span class="line">	if (root-&gt;key &lt; key) &#123;	&#x2F;&#x2F;插入新根，分别以t和t-&gt;rc为左右孩子</span><br><span class="line">		t-&gt;pa &#x3D; root &#x3D; new SplayNode&lt;T&gt;(key, NULL, t, t-&gt;rc);</span><br><span class="line">		if (HasRChild(t)) &#123;</span><br><span class="line">			t-&gt;rc-&gt;pa &#x3D; root;</span><br><span class="line">			t-&gt;rc &#x3D; NULL; </span><br><span class="line">		&#125;</span><br><span class="line">	&#125;else &#123;&#x2F;&#x2F;插入新根，分别以t-&gt;lc和t为左右孩子</span><br><span class="line">		t-&gt;pa &#x3D; root &#x3D; new SplayNode&lt;T&gt;(key, NULL, t-&gt;lc, t);</span><br><span class="line">		if (HasLChild(t)) &#123;</span><br><span class="line">			t-&gt;lc-&gt;pa &#x3D; root;</span><br><span class="line">			t-&gt;lc &#x3D; NULL; </span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return root;</span><br><span class="line">&#125;	&#x2F;&#x2F;无论key是否存在于原树中，返回时总有root-&gt;key &#x3D;&#x3D; key</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;删除值为key的节点</span><br><span class="line">template&lt;typename T&gt;</span><br><span class="line">inline bool SplayTree&lt;T&gt;::remove(const T &amp; key)</span><br><span class="line">&#123;</span><br><span class="line">	if (!root || key !&#x3D; search(key)-&gt;key)	&#x2F;&#x2F;若原树为空或目标不存在则不执行删除操作</span><br><span class="line">		return false;		</span><br><span class="line">	SplayNodePos(T)		t &#x3D; root;</span><br><span class="line">	&#x2F;&#x2F;注意上面执行了search操作，即此时已经伸展过原树，有root-&gt;key &#x3D;&#x3D; key</span><br><span class="line">	if (!HasLChild(root)) &#123;	&#x2F;&#x2F;若无左子树，直接删除根节点</span><br><span class="line">		root &#x3D; root-&gt;rc;</span><br><span class="line">		if (root-&gt;rc)</span><br><span class="line">			root-&gt;rc-&gt;pa &#x3D; NULL;</span><br><span class="line">	&#125;</span><br><span class="line">	else if (!HasRChild(root)) &#123;	&#x2F;&#x2F;若无右子树，直接删除根节点</span><br><span class="line">		root &#x3D; root-&gt;lc;</span><br><span class="line">		if (root-&gt;lc)</span><br><span class="line">			root-&gt;lc-&gt;pa &#x3D; NULL;</span><br><span class="line">	&#125;else &#123;	&#x2F;&#x2F;否则左右子树均存在，此时</span><br><span class="line">		SplayNodePos(T)		ltree &#x3D; root-&gt;lc;</span><br><span class="line">		ltree-&gt;pa &#x3D; NULL;	root-&gt;lc &#x3D; NULL;	&#x2F;&#x2F;暂时切除左子树</span><br><span class="line">		root &#x3D; root-&gt;rc; root-&gt;pa &#x3D; NULL;&#x2F;&#x2F;将删除节点和右子树分离</span><br><span class="line">		search(key);	&#x2F;&#x2F;再执行一次search操作，此时左侧key最小的节点会伸展至root，且root无左子树</span><br><span class="line">		root-&gt;lc &#x3D; ltree;	ltree-&gt;pa &#x3D; root;	&#x2F;&#x2F;将原左子树接回整树中</span><br><span class="line">	&#125;</span><br><span class="line">	delete t;	&#x2F;&#x2F;删除原根节点</span><br><span class="line">	return true;	&#x2F;&#x2F;成功删除</span><br><span class="line">&#125;</span><br><span class="line">#endif &#x2F;&#x2F; ! _SPLAYTREE_DECLARATION_H</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;	从节点v开始逐层进行伸展</span><br><span class="line">template&lt;typename T&gt;</span><br><span class="line">inline SplayNodePos(T) SplayTree&lt;T&gt;::splay(SplayNodePos(T)	&amp; v) &#123;&#x2F;&#x2F;v为因最近访问而需要伸展的节点</span><br><span class="line">	if (!v)		return	NULL;</span><br><span class="line">	SplayNodePos(T)	p &#x3D; NULL;</span><br><span class="line">	SplayNodePos(T) g &#x3D; NULL;	&#x2F;&#x2F;v的父亲以及祖父</span><br><span class="line">	while ((p &#x3D; v-&gt;pa) &amp;&amp; (g &#x3D; p-&gt;pa)	)&#123;&#x2F;&#x2F;	p、g均存在，可以做双层伸展</span><br><span class="line">		SplayNodePos(T)	gg &#x3D; g-&gt;pa;	&#x2F;&#x2F;gg为v的曾祖父</span><br><span class="line">		if (IsLChild(v) &amp;&amp; IsLChild(p)) &#123;</span><br><span class="line">			attachAsLChild(p, v-&gt;rc);</span><br><span class="line">			attachAsLChild(g, p-&gt;rc);</span><br><span class="line">			attachAsRChild(v, p);</span><br><span class="line">			attachAsRChild(p, g);</span><br><span class="line">		&#125;</span><br><span class="line">		else if (IsRChild(v) &amp;&amp; IsRChild(p) )&#123;</span><br><span class="line">			attachAsRChild(p, v-&gt;lc);</span><br><span class="line">			attachAsRChild(g, p-&gt;lc);</span><br><span class="line">			attachAsLChild(v, p);</span><br><span class="line">			attachAsLChild(p, g);</span><br><span class="line">		&#125;</span><br><span class="line">		else if (IsLChild(v) &amp;&amp; IsRChild(p)) &#123;</span><br><span class="line">			attachAsRChild(g,v-&gt;lc);</span><br><span class="line">			attachAsLChild(p,v-&gt;rc);</span><br><span class="line">			attachAsRChild(v,p);</span><br><span class="line">			attachAsLChild(v,g);</span><br><span class="line">		&#125;</span><br><span class="line">		else if (IsRChild(v) &amp;&amp; IsLChild(p)) &#123;</span><br><span class="line">			attachAsLChild(g, v-&gt;rc);</span><br><span class="line">			attachAsRChild(g, v-&gt;lc);</span><br><span class="line">			attachAsLChild(v, p);</span><br><span class="line">			attachAsRChild(v, g);</span><br><span class="line">		&#125;</span><br><span class="line">		if (!gg)	v-&gt;pa &#x3D; NULL;		&#x2F;&#x2F;如果v的曾祖父gg不存在，则v现在是root</span><br><span class="line">		else	&#x2F;&#x2F;否则将v接到gg上</span><br><span class="line">			(g &#x3D;&#x3D; gg-&gt;lc)? attachAsLChild(gg, v) :attachAsRChild(gg, v);</span><br><span class="line">	&#125;	&#x2F;&#x2F;双层伸展结束，必有g&#x3D;&#x3D;NULL,但是p可能非空</span><br><span class="line">	if (p &#x3D; v-&gt;pa) &#123;		&#x2F;&#x2F;若p非空，再单独做一次单选</span><br><span class="line">		if (IsLChild(v)) &#123;</span><br><span class="line">			attachAsLChild(p, v-&gt;rc);</span><br><span class="line">			attachAsRChild(v,p);</span><br><span class="line">		&#125;</span><br><span class="line">		else &#123;</span><br><span class="line">			attachAsRChild(p, v-&gt;lc);</span><br><span class="line">			attachAsLChild(v, p);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	v-&gt;pa &#x3D; NULL;</span><br><span class="line">	return v;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>“main.cpp”</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&#x2F;&#x2F; SplayTree.cpp : 此文件包含 &quot;main&quot; 函数。程序执行将在此处开始并结束。</span><br><span class="line">&#x2F;&#x2F;</span><br><span class="line"></span><br><span class="line">#include &quot;pch.h&quot;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include&quot;SplayTree_Declaration.h&quot;</span><br><span class="line">#include&quot;SplayTree_Define.h&quot;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	SplayTree&lt;int&gt; t;</span><br><span class="line">	int n;</span><br><span class="line">	cout &lt;&lt; &quot;insert number:&quot;;</span><br><span class="line">	cin &gt;&gt; n;</span><br><span class="line">	cout &lt;&lt; &quot;insert:&quot;;</span><br><span class="line">	for (int i &#x3D; 0; i &lt; n; i++) &#123;</span><br><span class="line">		int tmp;</span><br><span class="line">		cin &gt;&gt; tmp;</span><br><span class="line">		t.insert(tmp);</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; &quot;PreOrder:&quot;;</span><br><span class="line">	t.preOrder();</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; &quot;InOrder:&quot;;</span><br><span class="line">	t.inOrder();</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; &quot;PostOrder:&quot;;</span><br><span class="line">	t.postOrder();</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; &quot;remove number:&quot;;</span><br><span class="line">	cin &gt;&gt; n;</span><br><span class="line">	cout &lt;&lt; &quot;remove:&quot;;</span><br><span class="line">	for (int i &#x3D; 0; i &lt; n; i++) &#123;</span><br><span class="line">		int tmp;</span><br><span class="line">		cin &gt;&gt; tmp;</span><br><span class="line">		t.remove(tmp);</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; &quot;PreOrder:&quot;;</span><br><span class="line">	t.preOrder();</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; &quot;InOrder:&quot;;</span><br><span class="line">	t.inOrder();</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; &quot;PostOrder:&quot;;</span><br><span class="line">	t.postOrder();</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">	return 0;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>高级搜索树-AVL树</title>
    <url>/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%AB%98%E7%BA%A7%E6%90%9C%E7%B4%A2%E6%A0%91-AVL%E6%A0%91/</url>
    <content><![CDATA[<p>AVL树是平衡二叉搜索树中的一种，在渐进意义下，AVL树可以将高度始终控制在O(log n)  以内，以保证每次查找、插入和删除操作均可以在O(log n)的时间内完成。</p>
<a id="more"></a>

<h3 id="平衡因子"><a href="#平衡因子" class="headerlink" title="平衡因子"></a>平衡因子</h3><p>定义任一结点v的平衡因子（balance factor）为其<strong>左右子树的高度差</strong></p>
<p>balfac(v)   =   height(v-&gt;lc)   -   height(v-&gt;rc)</p>
<p>AVL树即平衡因子受限的二叉搜索树—————各结点平衡因子的绝对值不超过1</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">template&lt;typename T&gt;</span><br><span class="line">inline bool AVLTree&lt;T&gt;::balanced(AVLNodePos(T) &amp;cur) &#123;</span><br><span class="line">	int lh &#x3D; 0, rh &#x3D; 0;</span><br><span class="line">	if (HasLChild(cur))</span><br><span class="line">		lh &#x3D; cur-&gt;lc-&gt;height;</span><br><span class="line">	if (HasRChild(cur))</span><br><span class="line">		rh &#x3D; cur-&gt;rc-&gt;height;</span><br><span class="line">	if ((lh - rh)*(lh - rh) &gt; 1)</span><br><span class="line">		return false;</span><br><span class="line">	return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="AVL树节点和AVL树的定义"><a href="#AVL树节点和AVL树的定义" class="headerlink" title="AVL树节点和AVL树的定义"></a>AVL树节点和AVL树的定义</h3><ol>
<li>AVL节点AVLNode的定义</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">template&lt;typename T&gt;</span><br><span class="line">struct AVLNode &#123;</span><br><span class="line">public:</span><br><span class="line">	T key;</span><br><span class="line">	int height;</span><br><span class="line">	AVLNodePos(T) pa;&#x2F;&#x2F;pa -- parent</span><br><span class="line">	AVLNodePos(T)  lc;&#x2F;&#x2F;lc -- left child</span><br><span class="line">	AVLNodePos(T)  rc;&#x2F;&#x2F;rc -- right child</span><br><span class="line">	&#x2F;&#x2F;构造函数</span><br><span class="line">	AVLNode(): height(0), pa(NULL), lc(NULL), rc(NULL) &#123;&#125;</span><br><span class="line">	AVLNode(T elem, int height &#x3D; 0, AVLNodePos(T)	 pa &#x3D; NULL, AVLNodePos(T) lc &#x3D; NULL, AVLNodePos(T)	 rc &#x3D; NULL) :</span><br><span class="line">		key(elem), height(height), pa(pa), lc(lc), rc(rc) &#123; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>AVL树AVLTree的定义如下</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">template&lt;typename T&gt;</span><br><span class="line">class AVLTree &#123;</span><br><span class="line">private:</span><br><span class="line">	AVLNodePos(T)	root;		&#x2F;&#x2F;树根</span><br><span class="line">public:</span><br><span class="line">	&#x2F;&#x2F;构造函数和析构函数</span><br><span class="line">	AVLTree():root(NULL)&#123;&#125;</span><br><span class="line">	~AVLTree() &#123;&#125;</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F;只读函数</span><br><span class="line">	int height() &#123; return Height(root); &#125;</span><br><span class="line">	&#x2F;&#x2F;遍历函数</span><br><span class="line">	void preOrder();	&#x2F;&#x2F;前序遍历</span><br><span class="line">	void inOrder();		&#x2F;&#x2F;中序遍历</span><br><span class="line">	void postOrder();	&#x2F;&#x2F;后序遍历</span><br><span class="line">	&#x2F;&#x2F;操作函数</span><br><span class="line">	AVLNodePos(T)	search(const T	 &amp;key);		&#x2F;&#x2F;查找函数，若存在值为key的节点返回相应节点，若不存在则返回NULL</span><br><span class="line">	AVLNodePos(T) insert(const T &amp;key);		&#x2F;&#x2F;插入值为key的节点</span><br><span class="line">	bool remove(const T &amp;key);	&#x2F;&#x2F;移除值为key的节点</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">	bool balanced(AVLNodePos(T) &amp;cur);	&#x2F;&#x2F;判断cur节点是否平衡</span><br><span class="line">	void upDataHeight(AVLNodePos(T) &amp;cur);	&#x2F;&#x2F;更新节点cur的高度</span><br><span class="line">	void preOrder(AVLNodePos(T) &amp;cur);		&#x2F;&#x2F;以cur节点为root进行前序遍历</span><br><span class="line">	void inOrder(AVLNodePos(T) &amp;cur);		&#x2F;&#x2F;以cur节点为root进行中序遍历</span><br><span class="line">	void postOrder(AVLNodePos(T) &amp;cur);	&#x2F;&#x2F;以cur节点为root进行后序遍历</span><br><span class="line">	AVLNodePos(T) searchIn(const T &amp; key, AVLNodePos(T) cur, AVLNodePos(T)&amp; hot);	&#x2F;&#x2F;以cur节点为root查找值为key的节点，hot为返回节点的父节点</span><br><span class="line">	AVLNodePos(T)	tallerChild(AVLNodePos(T) &amp;g);	&#x2F;&#x2F;返回g高度更高的孩子</span><br><span class="line">	AVLNodePos(T) connect34(AVLNodePos(T) a, AVLNodePos(T) b, AVLNodePos(T) c,	&#x2F;&#x2F;根据 &quot;3&quot;+&quot;4&quot;法则对子树进行调整</span><br><span class="line">		AVLNodePos(T) T0, AVLNodePos(T) T1, AVLNodePos(T) T2, AVLNodePos(T) T3);</span><br><span class="line">	AVLNodePos(T)	adjustNode(AVLNodePos(T)&amp; cur);	&#x2F;&#x2F;调整失衡节点cur,返回调整后得到局部子树的root，并将调整后子树接入原树</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="失衡调整"><a href="#失衡调整" class="headerlink" title="失衡调整"></a>失衡调整</h3><p>AVL树和常规二叉搜索树一样也支持插入、删除等动态修改操作，但是经过这类操作之后节点的高度可能发生变化，以至于不再满足AVL树的条件。为此要定义相关使得搜索树平衡的调整算法。只需在每次动态操作后利用balanced()函数判断当前节点是否平衡，在找到第一个失衡节点g后，找到g高度更高的孩子p和p高度更高的孩子s这三个节点，根据相应g，p，s的关系能找到四棵子树T0,T1,T2,T3，利用 3 + 4 重构法则就能统一调整算法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;根据 &quot;3&quot;+&quot;4&quot;法则对子树进行调整</span><br><span class="line">template&lt;typename T&gt;</span><br><span class="line">AVLNodePos(T) AVLTree&lt;T&gt;::connect34(</span><br><span class="line">	AVLNodePos(T) a, AVLNodePos(T) b, AVLNodePos(T) c,</span><br><span class="line">	AVLNodePos(T) T0, AVLNodePos(T) T1, AVLNodePos(T) T2, AVLNodePos(T) T3)</span><br><span class="line">&#123;																					&#x2F;&#x2F;最终实现效果如下：</span><br><span class="line">	a-&gt;lc &#x3D; T0;	if (T0)	T0-&gt;pa &#x3D; a;								&#x2F;&#x2F;							b</span><br><span class="line">	a-&gt;rc &#x3D; T1;	if (T1)	T1-&gt;pa &#x3D; a;								&#x2F;&#x2F;						&#x2F;		\ </span><br><span class="line">	c-&gt;lc &#x3D; T2;	if (T2)	T2-&gt;pa &#x3D; c;								&#x2F;&#x2F;                  a				 c</span><br><span class="line">	c-&gt;rc &#x3D; T3;	if (T3)	T3-&gt;pa &#x3D; c;								&#x2F;&#x2F;				&#x2F;		 \		  &#x2F;     \ </span><br><span class="line">	b-&gt;lc &#x3D; a;		b-&gt;rc &#x3D; c;									&#x2F;&#x2F;           T0          T1     T2       T3</span><br><span class="line">	a-&gt;pa &#x3D; b;	c-&gt;pa &#x3D; b;</span><br><span class="line">	b-&gt;pa &#x3D; NULL;</span><br><span class="line">	upDataHeight(a); </span><br><span class="line">	upDataHeight(c); </span><br><span class="line">	upDataHeight(b);	&#x2F;&#x2F;更新高度</span><br><span class="line">	return b;	&#x2F;&#x2F;返回b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;调整失衡节点cur,返回调整后得到局部子树的root，并将调整后子树接入原树</span><br><span class="line">template&lt;typename T&gt;</span><br><span class="line">AVLNodePos(T) AVLTree&lt;T&gt;::adjustNode(AVLNodePos(T)	&amp;g) &#123;</span><br><span class="line">	&#x2F;&#x2F;一旦发现失衡	找到g，p，s 三个节点				&#x2F;&#x2F;g --grandfa</span><br><span class="line">	AVLNodePos(T)  p &#x3D; tallerChild(g);	&#x2F;&#x2F;p --parent</span><br><span class="line">	AVLNodePos(T)  s &#x3D; tallerChild(p);		&#x2F;&#x2F;s --son</span><br><span class="line">	AVLNodePos(T)	gg &#x3D; g-&gt;pa;	&#x2F;&#x2F;gg -- g&#39;s parent</span><br><span class="line">	if (IsLChild(s) &amp;&amp; IsLChild(p))		&#x2F;&#x2F;left -- left </span><br><span class="line">		g &#x3D; connect34(s, p, g, s-&gt;lc, s-&gt;rc, p-&gt;rc, g-&gt;rc);</span><br><span class="line">	else if (IsRChild(s) &amp;&amp; IsLChild(p))	&#x2F;&#x2F;right -- left</span><br><span class="line">		g &#x3D; connect34(p, s, g, p-&gt;lc, s-&gt;lc, s-&gt;rc, g-&gt;rc);</span><br><span class="line">	else if (IsRChild(s) &amp;&amp; IsRChild(p))	&#x2F;&#x2F;right -- right</span><br><span class="line">		g &#x3D; connect34(g, p, s, g-&gt;lc, p-&gt;lc, s-&gt;lc, s-&gt;rc);</span><br><span class="line">	else if (IsLChild(s) &amp;&amp; IsRChild(p))	&#x2F;&#x2F;left -- left</span><br><span class="line">		g &#x3D; connect34(g, s, p, g-&gt;lc, s-&gt;lc, s-&gt;rc, p-&gt;rc);</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F;将调整后子树接回原树</span><br><span class="line">	if (!gg)		root &#x3D; g;&#x2F;&#x2F;	gg为NULL说明g为root，更新root</span><br><span class="line">	else &#123;	&#x2F;&#x2F;连接gg和 g</span><br><span class="line">		if (gg-&gt;key &gt; g-&gt;key) &#123;&#x2F;&#x2F;作为左子树接入</span><br><span class="line">			gg-&gt;lc &#x3D; g;</span><br><span class="line">			g-&gt;pa &#x3D; gg;</span><br><span class="line">		&#125;</span><br><span class="line">		else &#123;&#x2F;&#x2F;作为右子树接入</span><br><span class="line">			gg-&gt;rc &#x3D; g;</span><br><span class="line">			g-&gt;pa &#x3D; gg;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	upDataHeight(gg);&#x2F;&#x2F;g的高度已经在connect34时更新，故更新连接g后的gg高度</span><br><span class="line">	return g;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="插入和删除操作"><a href="#插入和删除操作" class="headerlink" title="插入和删除操作"></a>插入和删除操作</h3><p>插入和删除操作同搜索二叉树一样，只是每一次都要节点检查是否平衡，如果失衡则进行调整</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;AVLNodePos(T) searchIn(const T &amp; key, AVLNodePos(T) cur, AVLNodePos(T)&amp; hot);以cur节点为root查找值为key的节点，hot为返回节点的父节点</span><br><span class="line">&#x2F;&#x2F;插入值为key的节点</span><br><span class="line">template&lt;typename T&gt;</span><br><span class="line">AVLNodePos(T) AVLTree&lt;T&gt;::insert(const T &amp; key)</span><br><span class="line">&#123;</span><br><span class="line">	AVLNodePos(T)	cur_pa&#x3D;NULL;</span><br><span class="line">	AVLNodePos(T) x &#x3D; searchIn(key, root, cur_pa);</span><br><span class="line">	if (x)	return x;	&#x2F;&#x2F;已经存在值为key的节点	</span><br><span class="line">	&#x2F;&#x2F;否则确认key不存在</span><br><span class="line">	if (!root)</span><br><span class="line">		x &#x3D; root &#x3D; new AVLNode&lt;T&gt;(key);</span><br><span class="line">	else &#123;</span><br><span class="line">		&#x2F;&#x2F;连接节点</span><br><span class="line">		x &#x3D; new AVLNode&lt;T&gt;(key,0,cur_pa);</span><br><span class="line">		if (x-&gt;key &gt; cur_pa-&gt;key)</span><br><span class="line">			cur_pa-&gt;rc &#x3D; x;</span><br><span class="line">		else</span><br><span class="line">			cur_pa-&gt;lc &#x3D; x;</span><br><span class="line">		upDataHeight(x);	&#x2F;&#x2F;更新高度</span><br><span class="line">	&#125;</span><br><span class="line">	for (AVLNodePos(T) g &#x3D; cur_pa; g; g &#x3D; g-&gt;pa) &#123;	&#x2F;&#x2F;从	插入节点的父节点开始向上检查</span><br><span class="line">		if (!balanced(g)) &#123;&#x2F;&#x2F;若g失衡</span><br><span class="line">			adjustNode(g);&#x2F;&#x2F;调整以g为root的局部子树</span><br><span class="line">			break;	&#x2F;&#x2F;g复平衡后，局部子树高度必然复原，其祖先亦如此，故调整可到此结束</span><br><span class="line">		&#125;else &#123;&#x2F;&#x2F;否则g平衡</span><br><span class="line">			upDataHeight(g);		&#x2F;&#x2F;更新高度</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return x;	&#x2F;&#x2F;返回新插入节点位置</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;移除值为key的节点</span><br><span class="line">template&lt;typename T&gt;</span><br><span class="line">inline bool AVLTree&lt;T&gt;::remove(const T &amp; key)</span><br><span class="line">&#123;</span><br><span class="line">	AVLNodePos(T)	x &#x3D; search(key);</span><br><span class="line">	if (!x)	</span><br><span class="line">		return false;&#x2F;&#x2F;不存在值为key的节点</span><br><span class="line">	AVLNodePos(T)	w &#x3D; x;	&#x2F;&#x2F;w是实际被摘除节点</span><br><span class="line">	if (!HasLChild(x)) &#123;&#x2F;&#x2F;	如果x没有左子树，用右子树代替x</span><br><span class="line">		if (IsRoot(x))</span><br><span class="line">			root &#x3D; x-&gt;rc;</span><br><span class="line">		else &#123;</span><br><span class="line">			if (IsLChild(x))	x-&gt;pa-&gt;lc &#x3D; x-&gt;rc;</span><br><span class="line">			else x-&gt;pa-&gt;rc &#x3D; x-&gt;rc;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	else if (!HasRChild(x)) &#123;&#x2F;&#x2F;如果x没有右子树， 用左子树替代</span><br><span class="line">		if (IsRoot(x))</span><br><span class="line">			root &#x3D; x-&gt;lc;</span><br><span class="line">		else &#123;</span><br><span class="line">			if (IsLChild(x))	x-&gt;pa-&gt;lc &#x3D; x-&gt;lc;</span><br><span class="line">			else x-&gt;pa-&gt;rc &#x3D; x-&gt;lc;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;else &#123;	&#x2F;&#x2F;否则有左右子树</span><br><span class="line">		&#x2F;&#x2F;取w为x的直接后继</span><br><span class="line">		w &#x3D; x-&gt;rc;</span><br><span class="line">		while (HasLChild(w))</span><br><span class="line">			w &#x3D; w-&gt;lc;</span><br><span class="line">		&#x2F;&#x2F;交换数据</span><br><span class="line">		T tmp &#x3D; x-&gt;key;</span><br><span class="line">		x-&gt;key &#x3D; w-&gt;key;</span><br><span class="line">		w-&gt;key &#x3D; tmp;</span><br><span class="line">		if (HasRChild(w)) </span><br><span class="line">			w-&gt;rc-&gt;pa &#x3D; w-&gt;pa;</span><br><span class="line">		if (w-&gt;pa &#x3D;&#x3D; x)		&#x2F;&#x2F; 注意 w为x的右子这种情况   </span><br><span class="line">			x-&gt;rc &#x3D; w-&gt;rc;		</span><br><span class="line">		else</span><br><span class="line">			w-&gt;pa-&gt;lc &#x3D; w-&gt;rc;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">		upDataHeight(w-&gt;pa);</span><br><span class="line">	for (AVLNodePos(T) g &#x3D; w-&gt;pa; g; g &#x3D; g-&gt;pa) &#123;	&#x2F;&#x2F;从succ的父节点开始向上检查</span><br><span class="line">		if (!balanced(g)) &#123;&#x2F;&#x2F;若g失衡</span><br><span class="line">			g&#x3D;adjustNode(g);&#x2F;&#x2F;调整以g为root的局部子树</span><br><span class="line">			&#x2F;&#x2F;不同于插入操作，删除操作造成的失衡可能会传播</span><br><span class="line">		&#125;</span><br><span class="line">		else &#123;&#x2F;&#x2F;否则g平衡</span><br><span class="line">			upDataHeight(g);		&#x2F;&#x2F;更新高度</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	delete w;&#x2F;&#x2F;摘除w</span><br><span class="line">	return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="完整源码"><a href="#完整源码" class="headerlink" title="完整源码"></a>完整源码</h3><p>“AVLTree_Declaration.h” </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;#include&quot;pch.h&quot;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#ifndef  _AVL_TREE_DECLARATION_H</span><br><span class="line">#define  _AVL_TREE_DECLARATION_H</span><br><span class="line"></span><br><span class="line">#define AVLNodePos(T)	AVLNode&lt;T&gt; *</span><br><span class="line">&#x2F;&#x2F;宏定义</span><br><span class="line">#define IsRoot(x)		( !((x)-&gt;pa) )</span><br><span class="line">#define IsLChild(x)	( !(IsRoot(x)	) &amp;&amp; (x)&#x3D;&#x3D;(x)-&gt;pa-&gt;lc)</span><br><span class="line">#define IsRChild(x)	( !(IsRoot(x)	) &amp;&amp; (x)&#x3D;&#x3D;(x)-&gt;pa-&gt;rc)</span><br><span class="line">#define HasLChild(x)	((x)-&gt;lc )</span><br><span class="line">#define HasRChild(x)	((x)-&gt;rc )</span><br><span class="line">#define HasChild(x)		(HasLChild(x) || HasRChild(x))</span><br><span class="line">#define HasBothChild(x)	(HasRChild(x) &amp;&amp; HasLChild(x) )</span><br><span class="line">#define IsLeaf(x)		(! HasChild(x) )</span><br><span class="line">#define Height(x)		( (x)&#x3D;&#x3D;NULL? 0: (x)-&gt;height )	&#x2F;&#x2F;x的高度</span><br><span class="line">&#x2F;&#x2F;AVLNode 定义</span><br><span class="line">template&lt;typename T&gt;    </span><br><span class="line">struct AVLNode &#123;</span><br><span class="line">public:</span><br><span class="line">	T key;</span><br><span class="line">	int height;</span><br><span class="line">	AVLNodePos(T) pa;&#x2F;&#x2F;pa -- parent</span><br><span class="line">	AVLNodePos(T)  lc;&#x2F;&#x2F;lc -- left child</span><br><span class="line">	AVLNodePos(T)  rc;&#x2F;&#x2F;rc -- right child</span><br><span class="line">	&#x2F;&#x2F;构造函数</span><br><span class="line">	AVLNode(): height(0), pa(NULL), lc(NULL), rc(NULL) &#123;&#125;</span><br><span class="line">	AVLNode(T elem, int height &#x3D; 0, AVLNodePos(T)	 pa &#x3D; NULL, AVLNodePos(T) lc &#x3D; NULL, AVLNodePos(T)	 rc &#x3D; NULL) :</span><br><span class="line">		key(elem), height(height), pa(pa), lc(lc), rc(rc) &#123; &#125;</span><br><span class="line">&#125;;</span><br><span class="line">&#x2F;&#x2F;AVLTree 定义</span><br><span class="line">template&lt;typename T&gt;</span><br><span class="line">class AVLTree &#123;</span><br><span class="line">private:</span><br><span class="line">	AVLNodePos(T)	root;		&#x2F;&#x2F;树根</span><br><span class="line">public:</span><br><span class="line">	&#x2F;&#x2F;构造函数和析构函数</span><br><span class="line">	AVLTree():root(NULL)&#123;&#125;</span><br><span class="line">	~AVLTree() &#123;&#125;</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F;只读函数</span><br><span class="line">	int height() &#123; return Height(root); &#125;</span><br><span class="line">	&#x2F;&#x2F;遍历函数</span><br><span class="line">	void preOrder();	&#x2F;&#x2F;前序遍历</span><br><span class="line">	void inOrder();		&#x2F;&#x2F;中序遍历</span><br><span class="line">	void postOrder();	&#x2F;&#x2F;后序遍历</span><br><span class="line">	&#x2F;&#x2F;操作函数</span><br><span class="line">	AVLNodePos(T)	search(const T	 &amp;key);		&#x2F;&#x2F;查找函数，若存在值为key的节点返回相应节点，若不存在则返回NULL</span><br><span class="line">	AVLNodePos(T) insert(const T &amp;key);		&#x2F;&#x2F;插入值为key的节点</span><br><span class="line">	bool remove(const T &amp;key);	&#x2F;&#x2F;移除值为key的节点</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">	bool balanced(AVLNodePos(T) &amp;cur);	&#x2F;&#x2F;判断cur节点是否平衡</span><br><span class="line">	void upDataHeight(AVLNodePos(T) &amp;cur);	&#x2F;&#x2F;更新节点cur的高度</span><br><span class="line">	void preOrder(AVLNodePos(T) &amp;cur);		&#x2F;&#x2F;以cur节点为root进行前序遍历</span><br><span class="line">	void inOrder(AVLNodePos(T) &amp;cur);		&#x2F;&#x2F;以cur节点为root进行中序遍历</span><br><span class="line">	void postOrder(AVLNodePos(T) &amp;cur);	&#x2F;&#x2F;以cur节点为root进行后序遍历</span><br><span class="line">	AVLNodePos(T) searchIn(const T &amp; key, AVLNodePos(T) cur, AVLNodePos(T)&amp; hot);	&#x2F;&#x2F;以cur节点为root查找值为key的节点，hot为返回节点的父节点</span><br><span class="line">	AVLNodePos(T)	tallerChild(AVLNodePos(T) &amp;g);	&#x2F;&#x2F;返回g高度更高的孩子</span><br><span class="line">	AVLNodePos(T) connect34(AVLNodePos(T) a, AVLNodePos(T) b, AVLNodePos(T) c,	&#x2F;&#x2F;根据 &quot;3&quot;+&quot;4&quot;法则对子树进行调整</span><br><span class="line">		AVLNodePos(T) T0, AVLNodePos(T) T1, AVLNodePos(T) T2, AVLNodePos(T) T3);</span><br><span class="line">	AVLNodePos(T)	adjustNode(AVLNodePos(T)&amp; cur);	&#x2F;&#x2F;调整失衡节点cur,返回调整后得到局部子树的root，并将调整后子树接入原树</span><br><span class="line">&#125;;</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>

<p>“AVLTree_Define.h”</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;具体实现</span><br><span class="line">&#x2F;&#x2F;#include&quot;pch.h&quot;</span><br><span class="line">#include &quot;AVLTree_Declaration.h&quot;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">#ifndef _AVL_TREE_DEFINE_H</span><br><span class="line">#define _AVL_TREE_DEFINE_H</span><br><span class="line"></span><br><span class="line">template&lt;typename T&gt;</span><br><span class="line">inline void AVLTree&lt;T&gt;::preOrder(AVLNodePos(T) &amp; cur)</span><br><span class="line">&#123;</span><br><span class="line">	if (!cur)	return;</span><br><span class="line">	std::cout &lt;&lt; cur-&gt;key &lt;&lt; &quot; &quot;;</span><br><span class="line">	preOrder(cur-&gt;lc);</span><br><span class="line">	preOrder(cur-&gt;rc);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;typename T&gt;</span><br><span class="line">inline void AVLTree&lt;T&gt;::inOrder(AVLNodePos(T) &amp; cur)</span><br><span class="line">&#123;</span><br><span class="line">	if (!cur)	return;</span><br><span class="line">	inOrder(cur-&gt;lc);</span><br><span class="line">	std::cout &lt;&lt; cur-&gt;key &lt;&lt; &quot; &quot;;</span><br><span class="line">	inOrder(cur-&gt;rc);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;typename T&gt;</span><br><span class="line">inline void AVLTree&lt;T&gt;::postOrder(AVLNodePos(T)&amp; cur)</span><br><span class="line">&#123;</span><br><span class="line">	if (!cur)	return;</span><br><span class="line">	postOrder(cur-&gt;lc);</span><br><span class="line">	postOrder(cur-&gt;rc);</span><br><span class="line">	std::cout &lt;&lt; cur-&gt;key &lt;&lt; &quot; &quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;typename T&gt;</span><br><span class="line">inline void AVLTree&lt;T&gt;::preOrder()</span><br><span class="line">&#123;</span><br><span class="line">	preOrder(root);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;typename T&gt;</span><br><span class="line">inline void AVLTree&lt;T&gt;::inOrder()</span><br><span class="line">&#123;</span><br><span class="line">	inOrder(root);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">template&lt;typename T&gt;</span><br><span class="line">inline void AVLTree&lt;T&gt;::postOrder()</span><br><span class="line">&#123;</span><br><span class="line">	postOrder(root);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;判断cur节点是否平衡</span><br><span class="line">template&lt;typename T&gt;</span><br><span class="line">inline bool AVLTree&lt;T&gt;::balanced(AVLNodePos(T) &amp;cur) &#123;</span><br><span class="line">	int lh &#x3D; 0, rh &#x3D; 0;</span><br><span class="line">	if (HasLChild(cur))</span><br><span class="line">		lh &#x3D; cur-&gt;lc-&gt;height;</span><br><span class="line">	if (HasRChild(cur))</span><br><span class="line">		rh &#x3D; cur-&gt;rc-&gt;height;</span><br><span class="line">	if ((lh - rh)*(lh - rh) &gt; 1)</span><br><span class="line">		return false;</span><br><span class="line">	return true;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;返回g高度更高的孩子</span><br><span class="line">template&lt;typename T&gt;</span><br><span class="line">inline AVLNodePos(T)	AVLTree&lt;T&gt;::tallerChild(AVLNodePos(T) &amp;g) &#123;</span><br><span class="line">	if (HasBothChild(g)) &#123;</span><br><span class="line">		return (g-&gt;lc-&gt;height &gt;&#x3D; g-&gt;rc-&gt;height ? g-&gt;lc : g-&gt;rc);</span><br><span class="line">	&#125;</span><br><span class="line">	else if (HasLChild(g))</span><br><span class="line">		return g-&gt;lc;</span><br><span class="line">	else if (HasRChild(g))</span><br><span class="line">		return g-&gt;rc;</span><br><span class="line">	return NULL;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;更新节点cur的高度</span><br><span class="line">template&lt;typename T&gt;</span><br><span class="line">inline void AVLTree&lt;T&gt;::upDataHeight(AVLNodePos(T) &amp;	p)</span><br><span class="line">&#123;</span><br><span class="line">	if (!p)	return;</span><br><span class="line">	int tmp &#x3D; p-&gt;height;</span><br><span class="line">	if (IsLeaf(p))</span><br><span class="line">		p-&gt;height &#x3D; 1;</span><br><span class="line">	else if (HasBothChild(p))</span><br><span class="line">		p-&gt;height &#x3D; (p-&gt;lc-&gt;height &gt; p-&gt;rc-&gt;height) ? p-&gt;lc-&gt;height + 1 : p-&gt;rc-&gt;height + 1;</span><br><span class="line">	else if (HasLChild(p))</span><br><span class="line">		p-&gt;height &#x3D; p-&gt;lc-&gt;height + 1;</span><br><span class="line">	else if (HasRChild(p))</span><br><span class="line">		p-&gt;height &#x3D; p-&gt;rc-&gt;height + 1;</span><br><span class="line"></span><br><span class="line">	return;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;以cur节点为root查找值为key的节点，hot为返回节点的父节点</span><br><span class="line">template&lt;typename T&gt;</span><br><span class="line">inline AVLNodePos(T) AVLTree&lt;T&gt;::searchIn(const T &amp; key, AVLNodePos(T) cur, AVLNodePos(T)&amp; hot)</span><br><span class="line">&#123;</span><br><span class="line">	if (!cur || key &#x3D;&#x3D; cur-&gt;key)	return cur;</span><br><span class="line">	hot &#x3D; cur;</span><br><span class="line">	return searchIn(key, (key &lt; cur-&gt;key ? cur-&gt;lc : cur-&gt;rc), hot);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;查找函数，若存在值为key的节点返回相应节点，若不存在则返回NULL</span><br><span class="line">template&lt;typename T&gt;</span><br><span class="line">inline AVLNodePos(T) AVLTree&lt;T&gt;::search(const T &amp; key)</span><br><span class="line">&#123;</span><br><span class="line">	AVLNodePos(T) hot &#x3D; NULL;</span><br><span class="line">	return searchIn(key, root, hot);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;根据 &quot;3&quot;+&quot;4&quot;法则对子树进行调整</span><br><span class="line">template&lt;typename T&gt;</span><br><span class="line">AVLNodePos(T) AVLTree&lt;T&gt;::connect34(</span><br><span class="line">	AVLNodePos(T) a, AVLNodePos(T) b, AVLNodePos(T) c,</span><br><span class="line">	AVLNodePos(T) T0, AVLNodePos(T) T1, AVLNodePos(T) T2, AVLNodePos(T) T3)</span><br><span class="line">&#123;																					&#x2F;&#x2F;最终实现效果如下：</span><br><span class="line">	a-&gt;lc &#x3D; T0;	if (T0)	T0-&gt;pa &#x3D; a;								&#x2F;&#x2F;							b</span><br><span class="line">	a-&gt;rc &#x3D; T1;	if (T1)	T1-&gt;pa &#x3D; a;								&#x2F;&#x2F;						&#x2F;		\ </span><br><span class="line">	c-&gt;lc &#x3D; T2;	if (T2)	T2-&gt;pa &#x3D; c;								&#x2F;&#x2F;                  a				 c</span><br><span class="line">	c-&gt;rc &#x3D; T3;	if (T3)	T3-&gt;pa &#x3D; c;								&#x2F;&#x2F;				&#x2F;		 \		  &#x2F;     \ </span><br><span class="line">	b-&gt;lc &#x3D; a;		b-&gt;rc &#x3D; c;									&#x2F;&#x2F;             T0        T1      T2      T3</span><br><span class="line">	a-&gt;pa &#x3D; b;	c-&gt;pa &#x3D; b;</span><br><span class="line">	b-&gt;pa &#x3D; NULL;</span><br><span class="line">	upDataHeight(a); </span><br><span class="line">	upDataHeight(c); </span><br><span class="line">	upDataHeight(b);	&#x2F;&#x2F;更新高度</span><br><span class="line">	return b;	&#x2F;&#x2F;返回b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;调整失衡节点cur,返回调整后得到局部子树的root，并将调整后子树接入原树</span><br><span class="line">template&lt;typename T&gt;</span><br><span class="line">AVLNodePos(T) AVLTree&lt;T&gt;::adjustNode(AVLNodePos(T)	&amp;g) &#123;</span><br><span class="line">	&#x2F;&#x2F;一旦发现失衡	找到g，p，s 三个节点				&#x2F;&#x2F;g --grandfa</span><br><span class="line">	AVLNodePos(T)  p &#x3D; tallerChild(g);	&#x2F;&#x2F;p --parent</span><br><span class="line">	AVLNodePos(T)  s &#x3D; tallerChild(p);		&#x2F;&#x2F;s --son</span><br><span class="line">	AVLNodePos(T)	gg &#x3D; g-&gt;pa;	&#x2F;&#x2F;gg -- g&#39;s parent</span><br><span class="line">	if (IsLChild(s) &amp;&amp; IsLChild(p))		&#x2F;&#x2F;left -- left </span><br><span class="line">		g &#x3D; connect34(s, p, g, s-&gt;lc, s-&gt;rc, p-&gt;rc, g-&gt;rc);</span><br><span class="line">	else if (IsRChild(s) &amp;&amp; IsLChild(p))	&#x2F;&#x2F;right -- left</span><br><span class="line">		g &#x3D; connect34(p, s, g, p-&gt;lc, s-&gt;lc, s-&gt;rc, g-&gt;rc);</span><br><span class="line">	else if (IsRChild(s) &amp;&amp; IsRChild(p))	&#x2F;&#x2F;right -- right</span><br><span class="line">		g &#x3D; connect34(g, p, s, g-&gt;lc, p-&gt;lc, s-&gt;lc, s-&gt;rc);</span><br><span class="line">	else if (IsLChild(s) &amp;&amp; IsRChild(p))	&#x2F;&#x2F;left -- left</span><br><span class="line">		g &#x3D; connect34(g, s, p, g-&gt;lc, s-&gt;lc, s-&gt;rc, p-&gt;rc);</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F;将调整后子树接回原树</span><br><span class="line">	if (!gg)		root &#x3D; g;&#x2F;&#x2F;	gg为NULL说明g为root，更新root</span><br><span class="line">	else &#123;	&#x2F;&#x2F;连接gg和 g</span><br><span class="line">		if (gg-&gt;key &gt; g-&gt;key) &#123;&#x2F;&#x2F;作为左子树接入</span><br><span class="line">			gg-&gt;lc &#x3D; g;</span><br><span class="line">			g-&gt;pa &#x3D; gg;</span><br><span class="line">		&#125;</span><br><span class="line">		else &#123;&#x2F;&#x2F;作为右子树接入</span><br><span class="line">			gg-&gt;rc &#x3D; g;</span><br><span class="line">			g-&gt;pa &#x3D; gg;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	upDataHeight(gg);&#x2F;&#x2F;g的高度已经在connect34时更新，故更新连接g后的gg高度</span><br><span class="line">	return g;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;插入值为key的节点</span><br><span class="line">template&lt;typename T&gt;</span><br><span class="line">AVLNodePos(T) AVLTree&lt;T&gt;::insert(const T &amp; key)</span><br><span class="line">&#123;</span><br><span class="line">	AVLNodePos(T)	cur_pa&#x3D;NULL;</span><br><span class="line">	AVLNodePos(T) x &#x3D; searchIn(key, root, cur_pa);</span><br><span class="line">	if (x)	return x;	&#x2F;&#x2F;已经存在值为key的节点	</span><br><span class="line">	&#x2F;&#x2F;否则确认key不存在</span><br><span class="line">	if (!root)</span><br><span class="line">		x &#x3D; root &#x3D; new AVLNode&lt;T&gt;(key);</span><br><span class="line">	else &#123;</span><br><span class="line">		&#x2F;&#x2F;连接节点</span><br><span class="line">		x &#x3D; new AVLNode&lt;T&gt;(key,0,cur_pa);</span><br><span class="line">		if (x-&gt;key &gt; cur_pa-&gt;key)</span><br><span class="line">			cur_pa-&gt;rc &#x3D; x;</span><br><span class="line">		else</span><br><span class="line">			cur_pa-&gt;lc &#x3D; x;</span><br><span class="line">		upDataHeight(x);	&#x2F;&#x2F;更新高度</span><br><span class="line">	&#125;</span><br><span class="line">	for (AVLNodePos(T) g &#x3D; cur_pa; g; g &#x3D; g-&gt;pa) &#123;	&#x2F;&#x2F;从	插入节点的父节点开始向上检查</span><br><span class="line">		if (!balanced(g)) &#123;&#x2F;&#x2F;若g失衡</span><br><span class="line">			adjustNode(g);&#x2F;&#x2F;调整以g为root的局部子树</span><br><span class="line">			break;	&#x2F;&#x2F;g复平衡后，局部子树高度必然复原，其祖先亦如此，故调整可到此结束</span><br><span class="line">		&#125;else &#123;&#x2F;&#x2F;否则g平衡</span><br><span class="line">			upDataHeight(g);		&#x2F;&#x2F;更新高度</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return x;	&#x2F;&#x2F;返回新插入节点位置</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;删除值为key的节点</span><br><span class="line">template&lt;typename T&gt;</span><br><span class="line">inline bool AVLTree&lt;T&gt;::remove(const T &amp; key)</span><br><span class="line">&#123;</span><br><span class="line">	AVLNodePos(T)	x &#x3D; search(key);</span><br><span class="line">	if (!x)	</span><br><span class="line">		return false;&#x2F;&#x2F;不存在值为key的节点</span><br><span class="line">	AVLNodePos(T)	w &#x3D; x;	&#x2F;&#x2F;w是实际被摘除节点</span><br><span class="line">	if (!HasLChild(x)) &#123;&#x2F;&#x2F;	如果x没有左子树，用右子树代替x</span><br><span class="line">		if (IsRoot(x))</span><br><span class="line">			root &#x3D; x-&gt;rc;</span><br><span class="line">		else &#123;</span><br><span class="line">			if (IsLChild(x))	x-&gt;pa-&gt;lc &#x3D; x-&gt;rc;</span><br><span class="line">			else x-&gt;pa-&gt;rc &#x3D; x-&gt;rc;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	else if (!HasRChild(x)) &#123;&#x2F;&#x2F;如果x没有右子树， 用左子树替代</span><br><span class="line">		if (IsRoot(x))</span><br><span class="line">			root &#x3D; x-&gt;lc;</span><br><span class="line">		else &#123;</span><br><span class="line">			if (IsLChild(x))	x-&gt;pa-&gt;lc &#x3D; x-&gt;lc;</span><br><span class="line">			else x-&gt;pa-&gt;rc &#x3D; x-&gt;lc;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;else &#123;	&#x2F;&#x2F;否则有左右子树</span><br><span class="line">		&#x2F;&#x2F;取w为x的直接后继</span><br><span class="line">		w &#x3D; x-&gt;rc;</span><br><span class="line">		while (HasLChild(w))</span><br><span class="line">			w &#x3D; w-&gt;lc;</span><br><span class="line">		&#x2F;&#x2F;交换数据</span><br><span class="line">		T tmp &#x3D; x-&gt;key;</span><br><span class="line">		x-&gt;key &#x3D; w-&gt;key;</span><br><span class="line">		w-&gt;key &#x3D; tmp;</span><br><span class="line">		if (HasRChild(w)) </span><br><span class="line">			w-&gt;rc-&gt;pa &#x3D; w-&gt;pa;</span><br><span class="line">		if (w-&gt;pa &#x3D;&#x3D; x)		&#x2F;&#x2F; 注意 w为x的右子这种情况   </span><br><span class="line">			x-&gt;rc &#x3D; w-&gt;rc;		</span><br><span class="line">		else</span><br><span class="line">			w-&gt;pa-&gt;lc &#x3D; w-&gt;rc;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">		upDataHeight(w-&gt;pa);</span><br><span class="line">	for (AVLNodePos(T) g &#x3D; w-&gt;pa; g; g &#x3D; g-&gt;pa) &#123;	&#x2F;&#x2F;从succ的父节点开始向上检查</span><br><span class="line">		if (!balanced(g)) &#123;&#x2F;&#x2F;若g失衡</span><br><span class="line">			g&#x3D;adjustNode(g);&#x2F;&#x2F;调整以g为root的局部子树</span><br><span class="line">			&#x2F;&#x2F;不同于插入操作，删除操作造成的失衡可能会传播</span><br><span class="line">		&#125;</span><br><span class="line">		else &#123;&#x2F;&#x2F;否则g平衡</span><br><span class="line">			upDataHeight(g);		&#x2F;&#x2F;更新高度</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	delete w;&#x2F;&#x2F;摘除w</span><br><span class="line">	return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>

<p>“main.cpp”</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; main.cpp : 此文件包含 &quot;main&quot; 函数。程序执行将在此处开始并结束。</span><br><span class="line">&#x2F;&#x2F;</span><br><span class="line"></span><br><span class="line">#include &quot;pch.h&quot;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include&quot;AVLTree_Define.h&quot;</span><br><span class="line">#include&quot;AVLTree_Declaration.h&quot;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	AVLTree&lt;int&gt; t;</span><br><span class="line">	int n;</span><br><span class="line">	cout &lt;&lt; &quot;insert number:&quot;;</span><br><span class="line">	cin &gt;&gt; n;</span><br><span class="line">	cout &lt;&lt; &quot;insert:&quot; ;</span><br><span class="line">	for (int i &#x3D; 0; i &lt; n; i++) &#123;</span><br><span class="line">		int tmp;</span><br><span class="line">		cin &gt;&gt; tmp;</span><br><span class="line">		t.insert(tmp);</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; &quot;PreOrder:&quot;;</span><br><span class="line">	t.preOrder();</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; &quot;InOrder:&quot;;</span><br><span class="line">	t.inOrder();</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; &quot;PostOrder:&quot;;</span><br><span class="line">	t.postOrder();</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; &quot;remove number:&quot;;</span><br><span class="line">	cin &gt;&gt;n;</span><br><span class="line">	cout &lt;&lt; &quot;remove:&quot;;</span><br><span class="line">	for (int i &#x3D; 0; i &lt; n; i++) &#123;</span><br><span class="line">		int tmp;</span><br><span class="line">		cin &gt;&gt; tmp;</span><br><span class="line">		t.remove(tmp);</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; &quot;PreOrder:&quot;;</span><br><span class="line">	t.preOrder();</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; &quot;InOrder:&quot;;</span><br><span class="line">	t.inOrder();</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; &quot;PostOrder:&quot;;</span><br><span class="line">	t.postOrder();</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ 运算符重载</title>
    <url>/C-C/C++%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD/</url>
    <content><![CDATA[<p>当运算符被用于类类型的对象时，C++允许我们为其指定新的含义；同时我们也能自定义类类型之间的转换规则。</p>
<a id="more"></a>

<h3 id="运算符重载"><a href="#运算符重载" class="headerlink" title="运算符重载"></a>运算符重载</h3><p>运算符函数与普通函数相同，唯一的区别时运算符函数的名称为关键字operator + 运算符符号，同时我们不能重载内置类型的运算符，只能重载自定义类的运算符。</p>
<p>我们像调用普通函数一样调用运算符函数，例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">data1+data2;&#x2F;&#x2F;普通表达式</span><br><span class="line">operator+(data1,data2);&#x2F;&#x2F;等价函数调用表达式</span><br><span class="line"></span><br><span class="line">data1+&#x3D;data2;&#x2F;&#x2F;基于“调用的表达式”</span><br><span class="line">data1.operator+&#x3D;(data2);&#x2F;&#x2F;对成员运算符函数的等价调用</span><br></pre></td></tr></table></figure>

<p>可以被重载的运算符包括:<br><img src="https://img2018.cnblogs.com/blog/1012444/201906/1012444-20190628140308422-348786570.png" alt="可被重载运算符"><br>而以下运算符无法重载:</p>
<p><img src="https://img2018.cnblogs.com/blog/1012444/201906/1012444-20190628140322836-1002021228.png" alt="不可被重载运算符"></p>
<p>运算符重载的基本格式为:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">return_value classname::operator op(argument list)</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;*..body..*&#x2F;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="重载运算符原型"><a href="#重载运算符原型" class="headerlink" title="重载运算符原型"></a>重载运算符原型</h3><p>根据不同类型的运算符，重载运算符函数的原型也不同:</p>
<ol>
<li>考虑该运算符是否会修改算子，如果不会则argument list为<strong>const classname &amp;</strong>,如果会argument list为<strong>classname &amp;</strong>。</li>
<li>考虑返回类型return_value，基本上分为bool，const value 和reference三类。</li>
</ol>
<p>根据以上规则将运算符原型大致分为下面几类:</p>
<ol>
<li>算数运算符+ - * / % ^ &amp; | ~</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const T operator Op(const T &amp; l,const T &amp; r)    const;&#x2F;&#x2F;返回类型为常量，传入常量引用</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>关系运算符! &amp;&amp; || &lt; &lt;= &gt; &gt;= == !=</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bool operator Op(const T &amp; l,const T &amp; r)  const;&#x2F;&#x2F;返回类型为bool，传入常量引用</span><br></pre></td></tr></table></figure>

<p>或者</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bool operator Op(const T &amp; )  const;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>下标运算符[]</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">T &amp; operator[](int index);&#x2F;&#x2F;返回类型为引用可作为左值，传入index角标</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>递增递减运算符++ –</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">class A&#123;</span><br><span class="line">public:</span><br><span class="line">    &#x2F;*...*&#x2F;</span><br><span class="line">    &#x2F;&#x2F;对于++、--运算符比较特殊，因为根据在对象前后不同效果不同</span><br><span class="line">    const A &amp; operator ++();&#x2F;&#x2F;  prefix++，即++在对象前面</span><br><span class="line">    const A  operator ++(int );&#x2F;&#x2F; postfix++，即++在对象后面，此处int仅为重载区分</span><br><span class="line">    const A &amp; operator --();&#x2F;&#x2F; prefix--</span><br><span class="line">    const A  operator --(int );&#x2F;&#x2F; postfix--</span><br><span class="line">    &#x2F;*...*&#x2F;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>（复合）赋值运算符=、+= 、-= …</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">T &amp; operator Op(const T &amp; )   ;&#x2F;&#x2F;  为了与内置类型（复合）赋值运算符保持一致，返回其左侧运算对象引用</span><br></pre></td></tr></table></figure>

<ol start="6">
<li>输入输出运算符&lt;&lt; 、&gt;&gt;</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;与iostream标准库兼容的输入输出运算符必须是普通的非成员函数，而不能是类的成员函数</span><br><span class="line">ostream &amp; operator&lt;&lt;(ostream &amp;os,const T &amp; item)</span><br><span class="line">&#123;</span><br><span class="line">	&#x2F;*body*&#x2F;</span><br><span class="line"></span><br><span class="line">	&#x2F;*</span><br><span class="line">	os&lt;&lt;	&#x2F;*...*&#x2F;</span><br><span class="line">	*&#x2F;	</span><br><span class="line"></span><br><span class="line">	return os;</span><br><span class="line">&#125;</span><br><span class="line">istream &amp; operator&gt;&gt;(istream &amp;is,T &amp;item)</span><br><span class="line">&#123;</span><br><span class="line">	&#x2F;*body*&#x2F;</span><br><span class="line"></span><br><span class="line">	&#x2F;*</span><br><span class="line">	is&gt;&gt;	&#x2F;*...*&#x2F;</span><br><span class="line">	if(is)&#x2F;&#x2F;输入运算符要处理输入失败的情况，而输出不需要</span><br><span class="line">		&#x2F;*...*&#x2F;</span><br><span class="line">	else</span><br><span class="line">		&#x2F;*...*&#x2F;		</span><br><span class="line">	*&#x2F;</span><br><span class="line"></span><br><span class="line">	return is;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">T data;</span><br><span class="line">cin &gt;&gt; data;</span><br><span class="line">cout &lt;&lt; data;</span><br></pre></td></tr></table></figure>

<h3 id="选择作为成员函数还是非成员函数"><a href="#选择作为成员函数还是非成员函数" class="headerlink" title="选择作为成员函数还是非成员函数"></a>选择作为成员函数还是非成员函数</h3><p>运算符重载函数不仅可以作为类的成员函数，还可以作为非成员函数，作为类的友元函数。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">class A&#123;</span><br><span class="line">public:</span><br><span class="line">    &#x2F;*...*&#x2F;</span><br><span class="line">    friend const A operator+(const A &amp;l,const A &amp;r); </span><br><span class="line">    &#x2F;*...*&#x2F;</span><br><span class="line">&#125;</span><br><span class="line">const A operator-(const A &amp;l,const A &amp;r)&#123;</span><br><span class="line">    &#x2F;*...*&#x2F;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一般而言有以下规则：</p>
<ol>
<li>会改变对象本身的运算符或与给定类型密切相关的运算符通常为成员函数，例如++，–，*。</li>
<li>赋值= 、下表[]、调用()、成员访问箭头-&gt;必须为成员函数。</li>
<li>复合赋值运算符一般也重载为成员函数，但并不是必须的。</li>
<li>满足交换律（具有对称性）的运算符一般声明为非成员函数，这对混合类型的表达式有好处（例如int+double和double+int，我们希望他们的结果是一致的）</li>
</ol>
<h3 id="自定义Int类"><a href="#自定义Int类" class="headerlink" title="自定义Int类"></a>自定义Int类</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Int&#123;</span><br><span class="line">private:</span><br><span class="line">	int i;</span><br><span class="line">public:</span><br><span class="line">	Int():i(0)&#123;&#125;</span><br><span class="line">	Int(int j)&#123;i&#x3D;j;&#125;</span><br><span class="line">	</span><br><span class="line">	const Int operator+(const Int &amp;)	const;</span><br><span class="line">	const Int operator-(const Int &amp;)	const;</span><br><span class="line">	</span><br><span class="line">	Int &amp; operator&#x3D;(const Int &amp;);</span><br><span class="line">	Int &amp; operator+&#x3D;(const Int &amp;);	</span><br><span class="line">	Int &amp; operator-&#x3D;(const Int &amp;);</span><br><span class="line">	</span><br><span class="line">	const Int&amp; operator++();</span><br><span class="line">	const Int operator++(int );</span><br><span class="line">	const Int&amp; operator--();</span><br><span class="line">	const Int operator--(int );</span><br><span class="line">	</span><br><span class="line">	bool operator &lt;(const Int &amp;)	const;</span><br><span class="line">	bool operator &#x3D;&#x3D;(const Int &amp;)	const;</span><br><span class="line">	bool operator !&#x3D;(const Int &amp;)	const;</span><br><span class="line">	bool operator &gt;(const Int &amp;)	const;</span><br><span class="line">	bool operator &gt;&#x3D;(const Int &amp;)	const;</span><br><span class="line">	bool operator &lt;&#x3D;(const Int &amp;)	const;	 </span><br><span class="line">&#125;; </span><br><span class="line">const Int Int::operator+(const Int &amp;that)	const&#123;</span><br><span class="line">	Int tmp(i+that.i);</span><br><span class="line">	return tmp;</span><br><span class="line">&#125;</span><br><span class="line">const Int Int::operator-(const Int &amp;that)	const&#123;</span><br><span class="line">	Int tmp(i-that.i);</span><br><span class="line">	return tmp;</span><br><span class="line">&#125;</span><br><span class="line">Int &amp; Int::operator&#x3D;(const Int &amp;that)&#123;</span><br><span class="line">	if(this!&#x3D;&amp;that)&#123;</span><br><span class="line">		this-&gt;i&#x3D;that.i;</span><br><span class="line">	&#125;</span><br><span class="line">	return *this;</span><br><span class="line">&#125;</span><br><span class="line">Int &amp; Int::operator+&#x3D;(const Int &amp;that)&#123;</span><br><span class="line">	this-&gt;i+&#x3D;that.i;</span><br><span class="line">	return *this;</span><br><span class="line">&#125;</span><br><span class="line">Int &amp; Int::operator-&#x3D;(const Int &amp;that)&#123;</span><br><span class="line">	this-&gt;i+&#x3D;that.i;</span><br><span class="line">	return *this;</span><br><span class="line">&#125;</span><br><span class="line">const Int&amp; Int::operator++()&#123;</span><br><span class="line">	*this	&#x3D;*this+1;</span><br><span class="line">	return *this;</span><br><span class="line">&#125;</span><br><span class="line">const Int Int::operator++(int)&#123;</span><br><span class="line">	Int old(*this);	&#x2F;&#x2F;拷贝构造 </span><br><span class="line">	++(*this);	&#x2F;&#x2F;调用const Int&amp; Int::operator++()</span><br><span class="line">	return old; </span><br><span class="line">&#125; </span><br><span class="line">const Int&amp; Int::operator--()&#123;</span><br><span class="line">	*this	&#x3D;*this-1;</span><br><span class="line">	return *this;</span><br><span class="line">&#125;</span><br><span class="line">const Int Int::operator--(int)&#123;</span><br><span class="line">	Int old(*this);	&#x2F;&#x2F;拷贝构造 </span><br><span class="line">	--(*this);	&#x2F;&#x2F;调用const Int&amp; Int::operator--()</span><br><span class="line">	return old; </span><br><span class="line">&#125; </span><br><span class="line">bool Int::operator &lt;(const Int &amp;that)	const&#123;</span><br><span class="line">	if(this-&gt;i&lt;that.i)</span><br><span class="line">		return true;</span><br><span class="line">	return false;	</span><br><span class="line">&#125;</span><br><span class="line">bool Int::operator &#x3D;&#x3D;(const Int &amp;that)	const&#123;</span><br><span class="line">	if(this-&gt;i&#x3D;&#x3D;that.i)</span><br><span class="line">		return true;</span><br><span class="line">	return false;	</span><br><span class="line">&#125; </span><br><span class="line">bool Int::operator !&#x3D;(const Int &amp;that)	const&#123;</span><br><span class="line">	return !(*this&#x3D;&#x3D;that);&#x2F;&#x2F;只使用&#x3D;&#x3D;和&lt;来定义其他比较符号，一方面方便修改，另一方面编译器会自动内联不影响使用效率 </span><br><span class="line">&#125;</span><br><span class="line">bool Int::operator &gt;(const Int &amp;that)	const&#123;</span><br><span class="line">	return (!(*this&lt;that))&amp;&amp;!(!(*this&#x3D;&#x3D;that));</span><br><span class="line">&#125;</span><br><span class="line">bool Int::operator &gt;&#x3D;(const Int &amp;that)	const&#123;</span><br><span class="line">	return (!(*this&lt;that));</span><br><span class="line">&#125;</span><br><span class="line">bool Int::operator &lt;&#x3D;(const Int &amp;that)	const&#123;</span><br><span class="line">	return (*this&lt;that)||(*this&#x3D;&#x3D;that);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ 对象的初始化</title>
    <url>/C-C/%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96/</url>
    <content><![CDATA[<p>C++中变量初始化包括三种方式:<strong>默认初始化</strong>、<strong>直接初始化</strong>、<strong>拷贝初始化</strong>。在C++中每个类都定义了对象被初始化的方式，<strong>构造函数</strong>的任务是初始化类的数据成员，只要类的对象被创造就会执行构造函数。</p>
<a id="more"></a>
<p>一个类被创建出来即使什么东西都不定义，编译器也会为我们生成下面的4个函数：</p>
<ol>
<li>默认构造函数(default constructor)</li>
<li>析构函数(destructor)</li>
<li>拷贝构造函数(copy constructor)</li>
<li>拷贝赋值操作符(copy-assignment operator)</li>
</ol>
<h2 id="默认初始化"><a href="#默认初始化" class="headerlink" title="默认初始化"></a>默认初始化</h2><p>默认初始化依赖于默认构造函数。</p>
<h3 id="默认构造函数（default-constructor"><a href="#默认构造函数（default-constructor" class="headerlink" title="默认构造函数（default constructor)"></a>默认构造函数（default constructor)</h3><p>默认构造函数<strong>无须任何实参</strong>，如果一个类没有显示定义构造函数，则编译器会隐式地定义一个默认构造函数，称为<strong>合成的默认构造函数(synthesized default constructor)</strong>，但是合成默认构造函数可能会失效，对于任何类都应定义默认构造函数。</p>
<h3 id="构造函数初始值列表（cosntructor-initializer-list）"><a href="#构造函数初始值列表（cosntructor-initializer-list）" class="headerlink" title="构造函数初始值列表（cosntructor initializer list）"></a>构造函数初始值列表（cosntructor initializer list）</h3><p>对于构造函数，建议使用<strong>初始值列表</strong>,例如对于下面这个类：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class A&#123;</span><br><span class="line">private:</span><br><span class="line">    int i;</span><br><span class="line">    double j;</span><br><span class="line">public:</span><br><span class="line">    &#x2F;*...*&#x2F;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有下面两种构造函数的写法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">A():i(0),j(0)&#123;&#125;&#x2F;&#x2F;列表初始化，直接将i、j显示地初始化为0，相当于拷贝构造函数，对内置类型直接拷贝，对类类型使用该类的拷贝构造函数</span><br><span class="line">A():&#123;i&#x3D;0;j&#x3D;0;&#125;&#x2F;&#x2F;先将i、j默认初始化再将i、j赋值为0</span><br></pre></td></tr></table></figure>
<p>第二种写法会<strong>先进行默认初始化再进行赋值</strong>，如果有些成员无法默认初始化(例如引用&amp;和常量const)只能显示地初始化则会造成错误,因而建议都使用列表初始化以防止出错。</p>
<h2 id="直接初始化和拷贝初始化"><a href="#直接初始化和拷贝初始化" class="headerlink" title="直接初始化和拷贝初始化"></a>直接初始化和拷贝初始化</h2><p>当用于类类型对象时，初始化的拷贝形式和直接形式有所不同：直接初始化<strong>直接调用与实参匹配的构造函数</strong>，拷贝初始化总是<strong>调用拷贝构造函数</strong>。拷贝初始化首先使用指定构造函数创建一个临时对象，然后用拷贝构造函数将那个临时对象拷贝到正在创建的对象。</p>
<h3 id="拷贝构造函数（copy-construcor"><a href="#拷贝构造函数（copy-construcor" class="headerlink" title="拷贝构造函数（copy construcor)"></a>拷贝构造函数（copy construcor)</h3><p>拷贝构造函数的声明为classname(const classname &amp;op),与合成默认构造函数不同，即使我们定义了其他构造函数，编译器也会为我们合成一个拷贝构造函数。例如我们在自定义的类内声明了一个形参为(const)classname 的构造函数，例如对于下面的类：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class A&#123;</span><br><span class="line">private:</span><br><span class="line">    int i;</span><br><span class="line">public:</span><br><span class="line">    A():i(0)&#123;&#125;</span><br><span class="line">    A(A op)&#123;i&#125;        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>则编译器会提示：[Error] invalid constructor; you probably meant ‘A (const A&amp;)’，说明编译器已经默认创建了声明为A(const A &amp;)的拷贝构造函数，即<strong>合成拷贝构造函数（synthesized copy constructor)</strong>，一般合成拷贝构造函数会将其参数的成员诸葛拷贝到正在创建的对象中，对类类型的成员使用该类的拷贝构造函数来拷贝，而内置类型的成员则是直接拷贝。</p>
<h3 id="区分拷贝初始化和直接初始化"><a href="#区分拷贝初始化和直接初始化" class="headerlink" title="区分拷贝初始化和直接初始化"></a>区分拷贝初始化和直接初始化</h3><p>使用直接初始化时，我们实际上时要求编译器使用普通的函数匹配来选择与我们提供的参数最匹配的构造函数；而使用拷贝初始化时，我们要求编译器将右侧运算对象通过拷贝构造函数拷贝到正在创建的对象中。</p>
<h3 id="关于拷贝构造函数和拷贝赋值运算符"><a href="#关于拷贝构造函数和拷贝赋值运算符" class="headerlink" title="关于拷贝构造函数和拷贝赋值运算符"></a>关于拷贝构造函数和拷贝赋值运算符</h3><p>拷贝赋值运算符本质上是一个函数。一般情况下我们总是以为在=运算符出现的地方都是调用copy assignment operator，但是当一个新对象被定义的时候，即便这个时候是使用了’=’运算符，它真实调用的是初始化函数copy constructor，而不是调用copy assignment operator去进行赋值操作。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class A&#123;</span><br><span class="line">    &#x2F;*...*&#x2F; </span><br><span class="line">&#125;</span><br><span class="line">A a;&#x2F;&#x2F;默认初始化</span><br><span class="line">A b(a);&#x2F;&#x2F;拷贝初始化</span><br><span class="line">A c&#x3D;a;&#x2F;&#x2F;虽然使用了&#x3D;运算符，但是此处调用的时A(const A &amp;)即拷贝构造函数</span><br><span class="line">A d;&#x2F;&#x2F;默认初始化</span><br><span class="line">d&#x3D;a;&#x2F;&#x2F;这里才是使用了拷贝赋值运算符,是赋值</span><br></pre></td></tr></table></figure>


<h3 id="何时发生拷贝初始化"><a href="#何时发生拷贝初始化" class="headerlink" title="何时发生拷贝初始化"></a>何时发生拷贝初始化</h3><ol>
<li>将一个对象作为实参传递给一个非引用类型的形参。</li>
<li>从一个返回类型为非引用类型的函数返回一个对象。</li>
<li>用花括号列表初始化一个数值中的元素或一个聚合类中的成员。</li>
</ol>
<h2 id="以例代文"><a href="#以例代文" class="headerlink" title="以例代文"></a>以例代文</h2><p>为了更好地理解三种初始化方式，使用下面这个例子</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class A&#123;</span><br><span class="line">private:</span><br><span class="line">	int i;</span><br><span class="line">	int j;</span><br><span class="line">public:</span><br><span class="line">	A()&#x2F;&#x2F;默认构造函数 </span><br><span class="line">	&#123;cout&lt;&lt;&quot;	A()&quot;&lt;&lt;endl;&#125;	</span><br><span class="line">	A(const A &amp;)&#x2F;&#x2F;拷贝构造函数 </span><br><span class="line">	&#123;cout&lt;&lt;&quot;	A(const A&amp;)&quot;&lt;&lt;endl;&#125;</span><br><span class="line">	A&amp; operator &#x3D;(const A &amp;)&#x2F;&#x2F;拷贝赋值操作符</span><br><span class="line">	&#123;cout&lt;&lt;&quot;	A &amp;operator &#x3D;(const A &amp;)&quot;&lt;&lt;endl;&#125;</span><br><span class="line">	A(int k)&#x2F;&#x2F;</span><br><span class="line">	&#123;cout&lt;&lt;&quot;	A(int k)&quot;&lt;&lt;endl;&#125; </span><br><span class="line">	A(int k,int m)</span><br><span class="line">	&#123;cout&lt;&lt;&quot;	A(int k,int m)&quot;&lt;&lt;endl;&#125;</span><br><span class="line">&#125;; </span><br><span class="line">A func(A temp)&#123;</span><br><span class="line">	return temp;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	cout&lt;&lt;&quot;p1:&quot;&lt;&lt;endl; </span><br><span class="line">		A p1;&#x2F;&#x2F;默认初始化 </span><br><span class="line">	cout&lt;&lt;&quot;p2:&quot;&lt;&lt;endl;</span><br><span class="line">		A p2(1);&#x2F;&#x2F;直接初始化 </span><br><span class="line">	cout&lt;&lt;&quot;p3:&quot;&lt;&lt;endl;</span><br><span class="line">		A p3(1,2);&#x2F;&#x2F;直接初始化</span><br><span class="line">	cout&lt;&lt;&quot;p4:&quot;&lt;&lt;endl;</span><br><span class="line">		A p4&#x3D;1;&#x2F;&#x2F;被编译器优化为A p4(1),直接初始化 </span><br><span class="line">	cout&lt;&lt;&quot;p5:&quot;&lt;&lt;endl;</span><br><span class="line">		A p5(p1);&#x2F;&#x2F;拷贝初始化</span><br><span class="line">	cout&lt;&lt;&quot;p6:&quot;&lt;&lt;endl;</span><br><span class="line">		A p6&#x3D;p1;&#x2F;&#x2F;仍然时拷贝初始化，虽然使用了&#x3D;</span><br><span class="line">	cout&lt;&lt;&quot;p7:&quot;&lt;&lt;endl;</span><br><span class="line">		A p7;&#x2F;&#x2F;先默认初始化</span><br><span class="line">		p7&#x3D;p1;&#x2F;&#x2F;使用了拷贝赋值运算符，是赋值 </span><br><span class="line">	cout&lt;&lt;&quot;p8:&quot;&lt;&lt;endl;</span><br><span class="line">		A p8;&#x2F;&#x2F;默认初始化 </span><br><span class="line">		p8&#x3D;func(p1);&#x2F;&#x2F;较复杂下面分析 </span><br><span class="line">return 0 ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>得到运行结果</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">p1:</span><br><span class="line">        A()&#x2F;&#x2F;默认初始化 </span><br><span class="line">p2:</span><br><span class="line">        A(int k)&#x2F;&#x2F;直接初始化 </span><br><span class="line">p3:</span><br><span class="line">        A(int k,int m)&#x2F;&#x2F;直接初始化</span><br><span class="line">p4:</span><br><span class="line">        A(int k)&#x2F;&#x2F;被编译器优化为A p4(1),直接初始化 </span><br><span class="line">p5:</span><br><span class="line">        A(const A&amp;)&#x2F;&#x2F;拷贝初始化</span><br><span class="line">p6:</span><br><span class="line">        A(const A&amp;)&#x2F;&#x2F;仍然时拷贝初始化，虽然使用了&#x3D;</span><br><span class="line">p7:</span><br><span class="line">        A()&#x2F;&#x2F;先默认初始化</span><br><span class="line">        A &amp;operator &#x3D;(const A &amp;)&#x2F;&#x2F;使用了拷贝赋值运算符，是赋值 </span><br><span class="line">p8:</span><br><span class="line">        A()&#x2F;&#x2F;先默认初始化</span><br><span class="line">        A(const A&amp;)&#x2F;&#x2F;将一个对象作为实参传递给一个非引用类型的形参，发生拷贝初始化，将temp拷贝初始化为p1</span><br><span class="line">        A(const A&amp;)&#x2F;&#x2F;从一个返回类型为非引用类型的函数返回一个对象，当func函数结束时要将返回值拷贝到临时对象，执行拷贝初始化</span><br><span class="line">        A &amp;operator &#x3D;(const A &amp;)&#x2F;&#x2F;将临时对象通过拷贝赋值运算符赋值给p8</span><br><span class="line">		&#x2F;&#x2F;注意这个时候有可能会被编译器优化！</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>语法</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ const关键字</title>
    <url>/C-C/const%E5%85%B3%E9%94%AE%E5%AD%97/</url>
    <content><![CDATA[<p>常类型是指使用类型修饰符const说明的类型，常类型的变量或对象的值是不能被更新的。</p>
<a id="more"></a>
<h2 id="常量指针和指针常量"><a href="#常量指针和指针常量" class="headerlink" title="常量指针和指针常量"></a>常量指针和指针常量</h2><h3 id="1-何为顶层const和底层const"><a href="#1-何为顶层const和底层const" class="headerlink" title="1. 何为顶层const和底层const"></a>1. 何为顶层const和底层const</h3><p>当const修饰指针的时候分为顶层const和底层const，声明指向常量的指针的const是<strong>底层const</strong>(常量指针，不能通过该指针来改变所指的内容)，声明指针常量的const是<strong>顶层const</strong>(指针常量，该指针是一个常量，指向地址不能改变)。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int a&#x3D;1;</span><br><span class="line"></span><br><span class="line">const int *p&#x3D;&amp;a;    &#x2F;&#x2F;该const是底层const，p为常量指针，不能通过*p来修改a的值</span><br><span class="line">&#x2F;&#x2F;*p&#x3D;2; &#x2F;&#x2F;错误，p指向的是常量</span><br><span class="line">p++;    &#x2F;&#x2F;正确，可以改变p所指的地址</span><br><span class="line"></span><br><span class="line">int *const q&#x3D;&amp;a;    &#x2F;&#x2F;该const是顶层const，q为指针常量，不能修改q指向的地址</span><br><span class="line">*q&#x3D;3;   &#x2F;&#x2F;正确，可以通过*q来改变a的值</span><br><span class="line">&#x2F;&#x2F;q++;  &#x2F;&#x2F;错误，不能改变q指向的地址</span><br><span class="line"></span><br><span class="line">const int *const r&#x3D;&amp;a;  &#x2F;&#x2F;r为常量指针常量，第一个const是底层const，第二个const是顶层const</span><br></pre></td></tr></table></figure>
<p><strong>注意</strong>：指向“常量”的指针不代表它所指向的内容一定是常量，只是代表不能通过解引用符（操作符*）来改变它所指向的内容。例如上面可以直接通过a=2赋值改变a的值</p>
<h3 id="2-如何区分底层const和顶层const"><a href="#2-如何区分底层const和顶层const" class="headerlink" title="2. 如何区分底层const和顶层const"></a>2. 如何区分底层const和顶层const</h3><p>const只对它左边的东西起作用，唯一的例外就是const本身就是最左边的修饰符，那么它才会对右边的东西起作用。const int *q=&amp;a和int const *q=&amp;a是一样的。即<strong>const在*右边时是顶层cosnt，此时指针是常量，const在*左边的时候是底层const，此时指针指向常量</strong>。</p>
<h3 id="3-区分底层const和顶层const的作用"><a href="#3-区分底层const和顶层const的作用" class="headerlink" title="3. 区分底层const和顶层const的作用"></a>3. 区分底层const和顶层const的作用</h3><ol>
<li><p>执行对象拷贝时有限制，常量的底层const不能赋值给非底层的const。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int a&#x3D;1;</span><br><span class="line">const int *p&#x3D;&amp;a;	&#x2F;&#x2F;p为底层const的指针</span><br><span class="line">&#x2F;&#x2F;int *const q&#x3D;p;	&#x2F;&#x2F;错误，不能将底层const指针赋值给非底层const指针 </span><br><span class="line">const int *r&#x3D;p;	&#x2F;&#x2F;正确，可以将底层const指针赋值给底层const指针 </span><br><span class="line"></span><br><span class="line">int *const m&#x3D;&amp;a;    &#x2F;&#x2F;顶层const</span><br><span class="line">const int *n&#x3D;m; &#x2F;&#x2F;正确，可以将顶层const赋值给底层const</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用命名的强制类型转换函数const_cast时，需要能够分辨底层const和顶层const，因为const_cast只能改变运算对象的底层const。</p>
</li>
</ol>
<h2 id="常量对象和常量成员函数"><a href="#常量对象和常量成员函数" class="headerlink" title="常量对象和常量成员函数"></a>常量对象和常量成员函数</h2><h3 id="1-常量对象"><a href="#1-常量对象" class="headerlink" title="1. 常量对象"></a>1. 常量对象</h3><p>C++语言中，在定义某个类的对象时，若在整个说明语句前或者在对象名前面加一个关键字const就可以把它定义为<strong>常量对象</strong>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;classname&gt; const A</span><br><span class="line">const &lt;classname&gt; A</span><br></pre></td></tr></table></figure>
<p>C++不允许在常量对象上调用非常量成员函数，同时不允许声明常量的成员函数修改对象。</p>
<h3 id="2-常量成员函数"><a href="#2-常量成员函数" class="headerlink" title="2. 常量成员函数"></a>2. 常量成员函数</h3><p>常量函数是C++对常量的一个扩展，它很好的确保了C++中类的封装性。在C++中，为了防止类的数据成员被非法访问，将类的成员函数分成了两类，一类是<strong>常量成员函数</strong>（观察者）；另一类是<strong>非常量成员函数</strong>（变异者）。在一个函数的签名后面加上关键字const后该函数就成了常量函数。对于常量函数，最关键的不同是编译器不允许其修改类的数据成员。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class A</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">	A():i(0)&#123;	cout&lt;&lt;&quot;A::A()&quot;&lt;&lt;endl;&#125;</span><br><span class="line">	~A()&#123;	cout&lt;&lt;&quot;A::~A()&quot;&lt;&lt;endl;&#125;</span><br><span class="line">    void read() const</span><br><span class="line">    &#123;	cout&lt;&lt;&quot;A::read(),now i&#x3D;&quot;&lt;&lt;i&lt;&lt;endl;&#125; &#x2F;&#x2F;常量成员函数</span><br><span class="line">    void change()</span><br><span class="line">    &#123;i&#x3D;1;	cout&lt;&lt;&quot;A::change(),now i&#x3D;&quot;&lt;&lt;i&lt;&lt;endl;&#125;  &#x2F;&#x2F;非常量成员函数  </span><br><span class="line">private:</span><br><span class="line"></span><br><span class="line">    int i;</span><br><span class="line"></span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure>

<p> 由于常量对象的状态不允许被修改，因此，通过<strong>常量对象调用非常量函数</strong>时将会产生语法错误。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">A m;    &#x2F;&#x2F;非常量对象</span><br><span class="line">m.read();   &#x2F;&#x2F;正确，非常量对象可以调用常量函数</span><br><span class="line">m.change(); &#x2F;&#x2F;正确，非常量对象可以调用非常量函数</span><br><span class="line"></span><br><span class="line">const A n&#x3D;m;    &#x2F;&#x2F;常量对象</span><br><span class="line">n.read();   &#x2F;&#x2F;正确，常量对象只能调用常量函数，因为不希望修改对象状态</span><br><span class="line">&#x2F;&#x2F;n.change();   &#x2F;&#x2F;错误，常量对象的状态不能被修改，而非常量函数存在修改对象状态的**可能**</span><br></pre></td></tr></table></figure>

<p>每个成员函数都有一个隐含的指向对象本身的this指针。而常量函数则包含一个this的常量指针。例如对上面的函数:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void read(const A*this) const;</span><br><span class="line">void change(A*this);</span><br></pre></td></tr></table></figure>

<p>对于常量函数，我们不能通过this指针去修改对象对应的内存块。但是这仅仅是编译器的限制，我们仍然可以绕过编译器的限制，去改变对象的状态。例如将read()改为如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void read() const</span><br><span class="line">&#123;</span><br><span class="line">    A* ptr  &#x3D;   (A*)this;   </span><br><span class="line">    ptr-&gt;i&#x3D;1;</span><br><span class="line">    cout&lt;&lt;&quot;A::read(),now i&#x3D;&quot;&lt;&lt;i&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如此就<strong>可以通过常量函数修改对象的成员</strong>。但是最好不要这样去使用。</p>
<h3 id="3-常量成员函数的重载问题"><a href="#3-常量成员函数的重载问题" class="headerlink" title="3. 常量成员函数的重载问题"></a>3. 常量成员函数的重载问题</h3><p>对于下面的类中的func函数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class A</span><br><span class="line">&#123;</span><br><span class="line">private:</span><br><span class="line">    &#x2F;*...*&#x2F;</span><br><span class="line">public:</span><br><span class="line">    void func() const;</span><br><span class="line">    void func();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对第一个func()函数，隐藏的形参为func(<strong>const A* this</strong>),而第二个func()函数形参为func(<strong>A * this</strong>),二者形参不同故构成了函数的重载，是允许的。存在同名同参数和返回值的常量函数和非常量函数时，具体调用哪个函数是根据调用对象是常量对像还是非常量对象来决定的。<strong>常量对象调用常量成员；非常量对象调用非常量的成员</strong>。     </p>
]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>语法</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ 内联(inline)函数</title>
    <url>/C-C/%E5%86%85%E8%81%94-inline-%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<p>inline是C++关键字，在函数声明或定义中，函数返回类型前加上关键字inline，即可以把函数指定为内联函数。</p>
<a id="more"></a>

<p>在c/c++中，为了解决一些频繁调用的小函数大量消耗栈空间的问题，特别的引入了inline修饰符，表示为内联函数。内联函数实质是在调用点将函数展开，从而减少了对堆栈的操作（在堆栈中调用函数较为复杂，直接展开为代码运行效率更高）。</p>
<p>内联函数牺牲了空间但是降低了调用函数时的额外开销，以空间换时间，在大部分情况下时值得的。</p>
<h3 id="内联函数的使用方法"><a href="#内联函数的使用方法" class="headerlink" title="内联函数的使用方法"></a>内联函数的使用方法</h3><p>在class之外，多一个inline修饰符。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class A&#123;</span><br><span class="line">private:</span><br><span class="line">    &#x2F;*...*&#x2F;</span><br><span class="line">public:</span><br><span class="line">    &#x2F;*...*&#x2F;</span><br><span class="line">    int add(int x,int y) &#123;return x+y;&#125;    </span><br><span class="line">    &#x2F;*...*&#x2F;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;*</span><br><span class="line">如果在类中未给出成员函数定义，而又想内联该函数的话，那在类外要加上inline，否则就认为不是内联的</span><br><span class="line">*&#x2F;</span><br><span class="line">inline int A::add(int x,int y)&#123;</span><br><span class="line">    &#x2F;*...*&#x2F;</span><br><span class="line">&#125;</span><br><span class="line">inline int add1(int x,int y)&#123;</span><br><span class="line">    &#x2F;*...*&#x2F;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在class之内定义的函数是自动内联的。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class A&#123;</span><br><span class="line">private:</span><br><span class="line">    &#x2F;*...*&#x2F;</span><br><span class="line">public:</span><br><span class="line">    &#x2F;*...*&#x2F;</span><br><span class="line">    int add(int x,int y) &#123;return x+y;&#125;    </span><br><span class="line">    &#x2F;*...*&#x2F;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="内联函数的使用规则"><a href="#内联函数的使用规则" class="headerlink" title="内联函数的使用规则"></a>内联函数的使用规则</h3><ol>
<li><p>inline说明对编译器来说只是一种建议，编译器可以选择忽略这个建议。对于过大的函数，编译器会忽略inline。</p>
</li>
<li><p>关键字inline 必须与<strong>函数定义体放在一起</strong>才能使函数成为内联，仅将inline 放在函数声明前面<strong>不起任何作用</strong>,inline函数实质上是一种<strong>声明</strong>，最好直接将内联函数定义一起放在.h文件中。</p>
</li>
</ol>
<h3 id="使用inline的时机"><a href="#使用inline的时机" class="headerlink" title="使用inline的时机"></a>使用inline的时机</h3><p>代码短小（例如只有2、3行）且多次调用。</p>
<p>若函数较大或有递归调用(Recursive functions)则不使用inline。</p>
<h3 id="inline函数与宏函数的差异"><a href="#inline函数与宏函数的差异" class="headerlink" title="inline函数与宏函数的差异"></a>inline函数与宏函数的差异</h3><p>宏</p>
<ol>
<li><p>宏调用是通过简单文本替换来实现的，不会对参数进行类型检查。</p>
</li>
<li><p>宏的使用是预处理器直接对宏代码进行调用，没有参数压栈、生成相应汇编代码、返回参数等时间花费。</p>
</li>
<li><p>宏可能会产生意想不到的边缘效应，很容易出错，要非常小心优先级的变动。</p>
</li>
</ol>
<p>内联</p>
<ol>
<li><p>inline 对编译器来说是一种请求，而不是命令。</p>
</li>
<li><p>C++中的内联机制既具备宏代码的效率，又增加了安全性，可以自由操作类的数据成员，而宏代码无法操作类的私有成员。</p>
</li>
</ol>
<p>例如对于下面代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#define add1(x,y)	((x)+(y)) &#x2F;&#x2F;宏定义</span><br><span class="line">using namespace std;</span><br><span class="line">inline int add2(int x,int y)&#123; &#x2F;&#x2F;内联</span><br><span class="line">	return x+y;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	double a&#x3D;1.0,b&#x3D;2.0;</span><br><span class="line">	printf(&quot; %d \n&quot;,add1(a,b));</span><br><span class="line">	printf(&quot; %d \n&quot;,add2(a,b));</span><br><span class="line">return 0 ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>得到结果</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0&#x2F;&#x2F;宏没有对类型检测</span><br><span class="line">3&#x2F;&#x2F;inline进行了强制类型转化</span><br></pre></td></tr></table></figure>
<p>因而建议在c++中用inline函数代替宏函数</p>
]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>语法</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ new和delete</title>
    <url>/C-C/c++%E4%B8%AD%E7%9A%84new%E5%92%8Cdelete/</url>
    <content><![CDATA[<p>在c++中堆内存的分配与释放是通过new和delete来实现的，new和delete是两个操作符，无需头文件支持</p>
<a id="more"></a>
<h2 id="new"><a href="#new" class="headerlink" title="new"></a>new</h2><h3 id="new运算符"><a href="#new运算符" class="headerlink" title="new运算符"></a>new运算符</h3><p>new运算符返回指向所分配类型对象的指针，new运算符首先<strong>向系统堆区申请足够的储存空间</strong>，如果申请成功，则再<strong>调用相应的默认构造函数</strong>，然后返回申请空间的地址</p>
<h3 id="new的使用方法"><a href="#new的使用方法" class="headerlink" title="new的使用方法"></a>new的使用方法</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int *p&#x3D; new int ;&#x2F;&#x2F;申请int</span><br><span class="line">int *psome&#x3D; new int[10];&#x2F;&#x2F;申请int数组</span><br><span class="line">A *q&#x3D; new A;&#x2F;&#x2F;申请自定义类型</span><br><span class="line">A *qsome&#x3D; new A[10];&#x2F;&#x2F;申请自定义类型数组</span><br></pre></td></tr></table></figure>
<h2 id="delete"><a href="#delete" class="headerlink" title="delete"></a>delete</h2><h3 id="delete运算符"><a href="#delete运算符" class="headerlink" title="delete运算符"></a>delete运算符</h3><p>delete运算符首先<strong>执行默认析构函数</strong>，然后再<strong>回收分配的空间</strong></p>
<h3 id="delete的使用方法"><a href="#delete的使用方法" class="headerlink" title="delete的使用方法"></a>delete的使用方法</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">delete p;&#x2F;&#x2F;释放int</span><br><span class="line">delete []psome;&#x2F;&#x2F;释放int数组</span><br><span class="line">delete q;&#x2F;&#x2F;释放自定义类型</span><br><span class="line">delete []qsome;&#x2F;&#x2F;释放自定义类型数组</span><br></pre></td></tr></table></figure>
<h3 id="关于delete-ptr和delete-ptr的差别"><a href="#关于delete-ptr和delete-ptr的差别" class="headerlink" title="关于delete ptr和delete []ptr的差别"></a>关于delete ptr和delete []ptr的差别</h3><p>回归到new和delete上，当我们调用operator new[]/new来分配数组对象时，编译器时系统内部会增加4或者8字节的分配空间用来保存所分配的数组对象的数量,可以理解为下面这对pair<br>| 储存分配空间的字节数 | 分配空间的地址 |<br>| -|-|<br>|           4|0xabcd<br>例如分配以下空间</p>
<p><code>A *psome =new A[10];</code></p>
<p>此时如果使用delete psome,则只会调用一次析构函数，但是会收回所有分配的空间；而使用delete []psome，则会依次调用psome[0]-psome[9]的析构函数，然后再收回所有的分配空间</p>
<p>例如对于下面的代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int count&#x3D;0;</span><br><span class="line">class A&#123;</span><br><span class="line">public:</span><br><span class="line">	int i;</span><br><span class="line">	A();</span><br><span class="line">	~A(); </span><br><span class="line">&#125;; </span><br><span class="line">A::A()&#123;&#x2F;&#x2F;构造函数</span><br><span class="line">	i&#x3D;count++;</span><br><span class="line">	cout&lt;&lt;&quot;A::A() i&#x3D;&quot;&lt;&lt;i&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">A::~A()&#123;&#x2F;&#x2F;析构函数</span><br><span class="line">	cout&lt;&lt;&quot;A::~A() i&#x3D;&quot;&lt;&lt;i&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	A *psome&#x3D; new A[10];</span><br><span class="line">	delete psome;</span><br><span class="line">	&#x2F;&#x2F;delete []psome;</span><br><span class="line">    return 0 ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行得到结果如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">A::A() i&#x3D;0&#x2F;&#x2F;依次执行构造函数</span><br><span class="line">A::A() i&#x3D;1</span><br><span class="line">A::A() i&#x3D;2</span><br><span class="line">A::A() i&#x3D;3</span><br><span class="line">A::A() i&#x3D;4</span><br><span class="line">A::A() i&#x3D;5</span><br><span class="line">A::A() i&#x3D;6</span><br><span class="line">A::A() i&#x3D;7</span><br><span class="line">A::A() i&#x3D;8</span><br><span class="line">A::A() i&#x3D;9</span><br><span class="line">A::~A() i&#x3D;0&#x2F;&#x2F;只执行依次析构函数，但空间全部回收</span><br></pre></td></tr></table></figure>
<p>可以看到只执行了依次析构函数，因为对于delete而言psome所指对象只有一个对象</p>
<p>如果执行的是delete []psome,得到结果如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">A::A() i&#x3D;0</span><br><span class="line">A::A() i&#x3D;1</span><br><span class="line">A::A() i&#x3D;2</span><br><span class="line">A::A() i&#x3D;3</span><br><span class="line">A::A() i&#x3D;4</span><br><span class="line">A::A() i&#x3D;5</span><br><span class="line">A::A() i&#x3D;6</span><br><span class="line">A::A() i&#x3D;7</span><br><span class="line">A::A() i&#x3D;8</span><br><span class="line">A::A() i&#x3D;9&#x2F;&#x2F;执行10次构造函数</span><br><span class="line">A::~A() i&#x3D;9</span><br><span class="line">A::~A() i&#x3D;8</span><br><span class="line">A::~A() i&#x3D;7</span><br><span class="line">A::~A() i&#x3D;6</span><br><span class="line">A::~A() i&#x3D;5</span><br><span class="line">A::~A() i&#x3D;4</span><br><span class="line">A::~A() i&#x3D;3</span><br><span class="line">A::~A() i&#x3D;2</span><br><span class="line">A::~A() i&#x3D;1</span><br><span class="line">A::~A() i&#x3D;0&#x2F;&#x2F;执行10次析构函数</span><br></pre></td></tr></table></figure>
<p>可以看到执行了10次析构函数，并且是从最后一个元素开始向前执行的，此时delete知道psome所指地址有多个对象，会通过上面的pair计算要执行析构函数的次数并依次执行</p>
<p>因此就结论而言，new/delete 、new []/delete[] 最好要配对使用</p>
<h2 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h2><p>1.不要使用delete去释放没有new的内存</p>
<p>2.不要重复delete</p>
<p>3.delete[]和new[]配套使用 ，delete和new配套使用</p>
<p>4.delete空指针是安全的（体现完备性）</p>
]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>语法</tag>
      </tags>
  </entry>
  <entry>
    <title>markdown基本语法</title>
    <url>/%E6%9D%82/%E6%B5%8B%E8%AF%95%E6%96%87%E7%AB%A0/</url>
    <content><![CDATA[<p>用于练习markdown语法与相关操作</p>
<a id="more"></a>
<h2 id="0-让文字显示摘要"><a href="#0-让文字显示摘要" class="headerlink" title="0.让文字显示摘要"></a>0.让文字显示摘要</h2><p>在MD格式文章正文插入&lt;!-- more --&gt;即可，这样只会显示之前的内容</p>
<h2 id="1-标题控制"><a href="#1-标题控制" class="headerlink" title="1.标题控制"></a>1.标题控制</h2><p>利用#号控制标题</p>
<p>1.#一级标题</p>
<h1 id="一级标题"><a href="#一级标题" class="headerlink" title="一级标题"></a>一级标题</h1><p>2.##二级标题  </p>
<h2 id="二级标题"><a href="#二级标题" class="headerlink" title="二级标题"></a>二级标题</h2><p>3.###三级标题  </p>
<h3 id="三级标题"><a href="#三级标题" class="headerlink" title="三级标题"></a>三级标题</h3><p>4.####四级标题  </p>
<h4 id="四级标题"><a href="#四级标题" class="headerlink" title="四级标题"></a>四级标题</h4><p>5.#####五级标题  </p>
<h5 id="五级标题"><a href="#五级标题" class="headerlink" title="五级标题"></a>五级标题</h5><p>6.######六级标题</p>
<h6 id="六级标题"><a href="#六级标题" class="headerlink" title="六级标题"></a>六级标题</h6><h2 id="2-段落分行"><a href="#2-段落分行" class="headerlink" title="2.段落分行"></a>2.段落分行</h2><p>只需要在两个段落间加一个空行，即回车两次</p>
<h2 id="3-区块引用"><a href="#3-区块引用" class="headerlink" title="3.区块引用"></a>3.区块引用</h2><blockquote>
<p>在引用的区块前加’&gt;’即可</p>
</blockquote>
<h2 id="4-超链接"><a href="#4-超链接" class="headerlink" title="4.超链接"></a>4.超链接</h2><p>[超链接显示文字](<a href="http://www.baidu.com" target="_blank" rel="noopener">http://www.baidu.com</a> “超链接title”)</p>
<p><a href="http://www.baidu.com" target="_blank" rel="noopener" title="超链接title">超链接显示文字</a></p>
<p>其中超链接title为浮动提示文字，懒狗不写</p>
<h2 id="5-图片显示"><a href="#5-图片显示" class="headerlink" title="5.图片显示"></a>5.图片显示</h2><p>![百度logo](<a href="https://www.baidu.com/img/bd_logo1.png?where=super" target="_blank" rel="noopener">https://www.baidu.com/img/bd_logo1.png?where=super</a>)</p>
<p><img src="https://www.baidu.com/img/bd_logo1.png?where=super" alt="百度logo"></p>
<h2 id="6-无序列表"><a href="#6-无序列表" class="headerlink" title="6.无序列表"></a>6.无序列表</h2><p>无序列表使用<em>、+、-标识，但是一般使用</em>来标识无序列表</p>
<p>* 无序列表</p>
<p>+ 无序列表</p>
<p>- 无序列表</p>
<p>显示</p>
<ul>
<li>无序列表</li>
</ul>
<ul>
<li>无序列表</li>
</ul>
<ul>
<li>无序列表<h2 id="7-有序列表"><a href="#7-有序列表" class="headerlink" title="7.有序列表"></a>7.有序列表</h2>用数字 + ‘.’ 标识</li>
</ul>
<p>1.有序列表1</p>
<p>   1.有序列表2</p>
<p>2.有序列表3</p>
<p>显示为</p>
<ol>
<li>有序列表1<ol>
<li>有序列表2</li>
</ol>
</li>
<li>有序列表3    </li>
</ol>
<h2 id="8-分隔线"><a href="#8-分隔线" class="headerlink" title="8.分隔线"></a>8.分隔线</h2><p>***</p>
<p>显示如下</p>
<hr>
<h2 id="9-字体修改"><a href="#9-字体修改" class="headerlink" title="9.字体修改"></a>9.字体修改</h2><p>*斜体*</p>
<p><em>斜体</em></p>
<p>**加粗**</p>
<p><strong>加粗</strong></p>
<p>***斜体加粗***</p>
<p><strong><em>斜体加粗</em></strong></p>
<h2 id="10-代码块"><a href="#10-代码块" class="headerlink" title="10.代码块"></a>10.代码块</h2><p>利用单个反引号`（在esc下面） 包裹代码</p>
<p>`int a=1 `</p>
<p><code>int a=1</code></p>
<p>处理多行代码是通过三个反引号包裹代码</p>
<p>```</p>
<p> int a=1;</p>
<p> int b=2;</p>
<p> int c=3;</p>
<p>```</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">int a&#x3D;1;</span><br><span class="line">int b&#x3D;2;</span><br><span class="line">int c&#x3D;3;</span><br></pre></td></tr></table></figure>

<h2 id="11-表格"><a href="#11-表格" class="headerlink" title="11.表格"></a>11.表格</h2><p>| a | b | c |</p>
<p>|—|—|—|</p>
<p>|1  |2  |3  |</p>
<p>|4  |5  |6  |</p>
<p>|7  |8  |9  |</p>
<table>
<thead>
<tr>
<th>a</th>
<th>b</th>
<th>c</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>2</td>
<td>3</td>
</tr>
<tr>
<td>4</td>
<td>5</td>
<td>6</td>
</tr>
<tr>
<td>7</td>
<td>8</td>
<td>9</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>杂</category>
      </categories>
      <tags>
        <tag>语法</tag>
        <tag>markdown</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/%E6%9D%82/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<a id="more"></a>

<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>
]]></content>
      <categories>
        <category>杂</category>
      </categories>
      <tags>
        <tag>Hello World</tag>
      </tags>
  </entry>
</search>
