<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>C++ 运算符重载</title>
    <url>/C-C/C++%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD/</url>
    <content><![CDATA[<p>当运算符被用于类类型的对象时，C++允许我们为其指定新的含义；同时我们也能自定义类类型之间的转换规则。</p>
<a id="more"></a>

<h3 id="运算符重载"><a href="#运算符重载" class="headerlink" title="运算符重载"></a>运算符重载</h3><p>运算符函数与普通函数相同，唯一的区别时运算符函数的名称为关键字operator + 运算符符号，同时我们不能重载内置类型的运算符，只能重载自定义类的运算符。</p>
<p>可以被重载的运算符包括:<br><img src="https://img2018.cnblogs.com/blog/1012444/201906/1012444-20190628140308422-348786570.png" alt="可被重载运算符"><br>而以下运算符无法重载:</p>
<p><img src="https://img2018.cnblogs.com/blog/1012444/201906/1012444-20190628140322836-1002021228.png" alt="不可被重载运算符"></p>
<p>运算符重载的基本格式为:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">return_value classname::operator op(argument list)</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;*..body..*&#x2F;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="重载运算符原型"><a href="#重载运算符原型" class="headerlink" title="重载运算符原型"></a>重载运算符原型</h3><p>根据不同类型的运算符，重载运算符函数的原型也不同:</p>
<ol>
<li>考虑该运算符是否会修改算子，如果不会则argument list为<strong>const classname &amp;</strong>,如果会argument list为<strong>classname &amp;</strong>。</li>
<li>考虑返回类型return_value，基本上分为bool，const value 和reference三类。</li>
</ol>
<p>根据以上规则将运算符原型大致分为下面5类:</p>
<ol>
<li>算数运算符+ - * / % ^ &amp; | ~</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const T operator Op(const T &amp; l,const T &amp; r)    const;&#x2F;&#x2F;返回类型为常量，传入常量引用</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>关系运算符! &amp;&amp; || &lt; &lt;= &gt; &gt;= == !=</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bool operator Op(const T &amp; l,const T &amp; r)  const;&#x2F;&#x2F;返回类型为bool，传入常量引用</span><br></pre></td></tr></table></figure>

<p>或者</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bool operator Op(const T &amp; )  const;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>下标运算符[]</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">T &amp; operator[](int index);&#x2F;&#x2F;返回类型为引用可作为左值，传入index角标</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>递增递减运算符++ –</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class A&#123;</span><br><span class="line">public:</span><br><span class="line">    &#x2F;*...*&#x2F;</span><br><span class="line">    &#x2F;&#x2F;对于++、--运算符比较特殊，因为根据在对象前后不同效果不同</span><br><span class="line">    const A &amp; operator ++();&#x2F;&#x2F;  prefix++，即++在对象前面</span><br><span class="line">    const A  operator ++(int );&#x2F;&#x2F; postfix++，即++在对象后面，此处int仅为重载区分</span><br><span class="line">    const A &amp; operator --();&#x2F;&#x2F; prefix--</span><br><span class="line">    const A  operator --(int );&#x2F;&#x2F; postfix--</span><br><span class="line">    &#x2F;*...*&#x2F;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;   </span><br><span class="line"></span><br><span class="line">5. （复合）赋值运算符&#x3D;、+&#x3D; 、-&#x3D; ...</span><br></pre></td></tr></table></figure>
<p>T &amp; operator Op(const T &amp; )   ;//  为了与内置类型（复合）赋值运算符保持一致，返回其左侧运算对象引用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">### 令运算符重载函数作为类的友元函数</span><br><span class="line"></span><br><span class="line">运算符重载函数不仅可以作为类的成员函数，还可以作为全局函数，作为类的友元函数。</span><br></pre></td></tr></table></figure>
<p>class A{<br>public:<br>    /<em>…</em>/<br>    friend const A operator+(const A &amp;l,const A &amp;r);<br>    /<em>…</em>/<br>}<br>const A operator-(const A &amp;l,const A &amp;r){<br>    /<em>…</em>/<br>}</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">一般而言有以下规则：</span><br><span class="line"></span><br><span class="line">1. 单目运算符一般重载为成员函数</span><br><span class="line">2. &#x3D; 、[]、()、-&gt;、-&gt;*必须重载为成员函数</span><br><span class="line">3. 赋值运算符一般也重载为成员函数</span><br><span class="line">4. 其他双目运算符一般重载为非成员函数，在类内进行友元声明，在类外进行定义</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 自定义Int类</span><br></pre></td></tr></table></figure>
<p>class Int{<br>private:<br>    int i;<br>public:<br>    Int():i(0){}<br>    Int(int j){i=j;}</p>
<pre><code>const Int operator+(const Int &amp;)    const;
const Int operator-(const Int &amp;)    const;

Int &amp; operator=(const Int &amp;);
Int &amp; operator+=(const Int &amp;);    
Int &amp; operator-=(const Int &amp;);

const Int&amp; operator++();
const Int operator++(int );
const Int&amp; operator--();
const Int operator--(int );

bool operator &lt;(const Int &amp;)    const;
bool operator ==(const Int &amp;)    const;
bool operator !=(const Int &amp;)    const;
bool operator &gt;(const Int &amp;)    const;
bool operator &gt;=(const Int &amp;)    const;
bool operator &lt;=(const Int &amp;)    const;     </code></pre><p>};<br>const Int Int::operator+(const Int &amp;that)    const{<br>    Int tmp(i+that.i);<br>    return tmp;<br>}<br>const Int Int::operator-(const Int &amp;that)    const{<br>    Int tmp(i-that.i);<br>    return tmp;<br>}<br>Int &amp; Int::operator=(const Int &amp;that){<br>    if(this!=&amp;that){<br>        this-&gt;i=that.i;<br>    }<br>    return <em>this;<br>}<br>Int &amp; Int::operator+=(const Int &amp;that){<br>    this-&gt;i+=that.i;<br>    return *this;<br>}<br>Int &amp; Int::operator-=(const Int &amp;that){<br>    this-&gt;i+=that.i;<br>    return *this;<br>}<br>const Int&amp; Int::operator++(){<br>    *this    =</em>this+1;<br>    return <em>this;<br>}<br>const Int Int::operator++(int){<br>    Int old(</em>this);    //拷贝构造<br>    ++(<em>this);    //调用const Int&amp; Int::operator++()<br>    return old;<br>}<br>const Int&amp; Int::operator–(){<br>    *this    =</em>this-1;<br>    return <em>this;<br>}<br>const Int Int::operator–(int){<br>    Int old(</em>this);    //拷贝构造<br>    –(<em>this);    //调用const Int&amp; Int::operator–()<br>    return old;<br>}<br>bool Int::operator &lt;(const Int &amp;that)    const{<br>    if(this-&gt;i&lt;that.i)<br>        return true;<br>    return false;<br>}<br>bool Int::operator ==(const Int &amp;that)    const{<br>    if(this-&gt;i==that.i)<br>        return true;<br>    return false;<br>}<br>bool Int::operator !=(const Int &amp;that)    const{<br>    return !(</em>this==that);//只使用==和&lt;来定义其他比较符号，一方面方便修改，另一方面编译器会自动内联不影响使用效率<br>}<br>bool Int::operator &gt;(const Int &amp;that)    const{<br>    return (!(<em>this&lt;that))&amp;&amp;!(!(</em>this==that));<br>}<br>bool Int::operator &gt;=(const Int &amp;that)    const{<br>    return (!(<em>this&lt;that));<br>}<br>bool Int::operator &lt;=(const Int &amp;that)    const{<br>    return (</em>this&lt;that)||(*this==that);<br>}<br>```</p>
]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ 对象的初始化</title>
    <url>/C-C/%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96/</url>
    <content><![CDATA[<p>C++中变量初始化包括三种方式:<strong>默认初始化</strong>、<strong>直接初始化</strong>、<strong>拷贝初始化</strong>。在C++中每个类都定义了对象被初始化的方式，<strong>构造函数</strong>的任务是初始化类的数据成员，只要类的对象被创造就会执行构造函数。</p>
<a id="more"></a>
<p>一个类被创建出来即使什么东西都不定义，编译器也会为我们生成下面的4个函数：</p>
<ol>
<li>默认构造函数(default constructor)</li>
<li>析构函数(destructor)</li>
<li>拷贝构造函数(copy constructor)</li>
<li>拷贝赋值操作符(copy-assignment operator)</li>
</ol>
<h2 id="默认初始化"><a href="#默认初始化" class="headerlink" title="默认初始化"></a>默认初始化</h2><p>默认初始化依赖于默认构造函数。</p>
<h3 id="默认构造函数（default-constructor"><a href="#默认构造函数（default-constructor" class="headerlink" title="默认构造函数（default constructor)"></a>默认构造函数（default constructor)</h3><p>默认构造函数<strong>无须任何实参</strong>，如果一个类没有显示定义构造函数，则编译器会隐式地定义一个默认构造函数，称为<strong>合成的默认构造函数(synthesized default constructor)</strong>，但是合成默认构造函数可能会失效，对于任何类都应定义默认构造函数。</p>
<h3 id="构造函数初始值列表（cosntructor-initializer-list）"><a href="#构造函数初始值列表（cosntructor-initializer-list）" class="headerlink" title="构造函数初始值列表（cosntructor initializer list）"></a>构造函数初始值列表（cosntructor initializer list）</h3><p>对于构造函数，建议使用<strong>初始值列表</strong>,例如对于下面这个类：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class A&#123;</span><br><span class="line">private:</span><br><span class="line">    int i;</span><br><span class="line">    double j;</span><br><span class="line">public:</span><br><span class="line">    &#x2F;*...*&#x2F;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有下面两种构造函数的写法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">A():i(0),j(0)&#123;&#125;&#x2F;&#x2F;列表初始化，直接将i、j显示地初始化为0，相当于拷贝构造函数，对内置类型直接拷贝，对类类型使用该类的拷贝构造函数</span><br><span class="line">A():&#123;i&#x3D;0;j&#x3D;0;&#125;&#x2F;&#x2F;先将i、j默认初始化再将i、j赋值为0</span><br></pre></td></tr></table></figure>
<p>第二种写法会<strong>先进行默认初始化再进行赋值</strong>，如果有些成员无法默认初始化(例如引用&amp;和常量const)只能显示地初始化则会造成错误,因而建议都使用列表初始化以防止出错。</p>
<h2 id="直接初始化和拷贝初始化"><a href="#直接初始化和拷贝初始化" class="headerlink" title="直接初始化和拷贝初始化"></a>直接初始化和拷贝初始化</h2><p>当用于类类型对象时，初始化的拷贝形式和直接形式有所不同：直接初始化<strong>直接调用与实参匹配的构造函数</strong>，拷贝初始化总是<strong>调用拷贝构造函数</strong>。拷贝初始化首先使用指定构造函数创建一个临时对象，然后用拷贝构造函数将那个临时对象拷贝到正在创建的对象。</p>
<h3 id="拷贝构造函数（copy-construcor"><a href="#拷贝构造函数（copy-construcor" class="headerlink" title="拷贝构造函数（copy construcor)"></a>拷贝构造函数（copy construcor)</h3><p>拷贝构造函数的声明为classname(const classname &amp;op),与合成默认构造函数不同，即使我们定义了其他构造函数，编译器也会为我们合成一个拷贝构造函数。例如我们在自定义的类内声明了一个形参为(const)classname 的构造函数，例如对于下面的类：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class A&#123;</span><br><span class="line">private:</span><br><span class="line">    int i;</span><br><span class="line">public:</span><br><span class="line">    A():i(0)&#123;&#125;</span><br><span class="line">    A(A op)&#123;i&#125;        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>则编译器会提示：[Error] invalid constructor; you probably meant ‘A (const A&amp;)’，说明编译器已经默认创建了声明为A(const A &amp;)的拷贝构造函数，即<strong>合成拷贝构造函数（synthesized copy constructor)</strong>，一般合成拷贝构造函数会将其参数的成员诸葛拷贝到正在创建的对象中，对类类型的成员使用该类的拷贝构造函数来拷贝，而内置类型的成员则是直接拷贝。</p>
<h3 id="区分拷贝初始化和直接初始化"><a href="#区分拷贝初始化和直接初始化" class="headerlink" title="区分拷贝初始化和直接初始化"></a>区分拷贝初始化和直接初始化</h3><p>使用直接初始化时，我们实际上时要求编译器使用普通的函数匹配来选择与我们提供的参数最匹配的构造函数；而使用拷贝初始化时，我们要求编译器将右侧运算对象通过拷贝构造函数拷贝到正在创建的对象中。</p>
<h3 id="关于拷贝构造函数和拷贝赋值运算符"><a href="#关于拷贝构造函数和拷贝赋值运算符" class="headerlink" title="关于拷贝构造函数和拷贝赋值运算符"></a>关于拷贝构造函数和拷贝赋值运算符</h3><p>拷贝赋值运算符本质上是一个函数。一般情况下我们总是以为在=运算符出现的地方都是调用copy assignment operator，但是当一个新对象被定义的时候，即便这个时候是使用了’=’运算符，它真实调用的是初始化函数copy constructor，而不是调用copy assignment operator去进行赋值操作。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class A&#123;</span><br><span class="line">    &#x2F;*...*&#x2F; </span><br><span class="line">&#125;</span><br><span class="line">A a;&#x2F;&#x2F;默认初始化</span><br><span class="line">A b(a);&#x2F;&#x2F;拷贝初始化</span><br><span class="line">A c&#x3D;a;&#x2F;&#x2F;虽然使用了&#x3D;运算符，但是此处调用的时A(const A &amp;)即拷贝构造函数</span><br><span class="line">A d;&#x2F;&#x2F;默认初始化</span><br><span class="line">d&#x3D;a;&#x2F;&#x2F;这里才是使用了拷贝赋值运算符,是赋值</span><br></pre></td></tr></table></figure>


<h3 id="何时发生拷贝初始化"><a href="#何时发生拷贝初始化" class="headerlink" title="何时发生拷贝初始化"></a>何时发生拷贝初始化</h3><ol>
<li>将一个对象作为实参传递给一个非引用类型的形参。</li>
<li>从一个返回类型为非引用类型的函数返回一个对象。</li>
<li>用花括号列表初始化一个数值中的元素或一个聚合类中的成员。</li>
</ol>
<h2 id="以例代文"><a href="#以例代文" class="headerlink" title="以例代文"></a>以例代文</h2><p>为了更好地理解三种初始化方式，使用下面这个例子</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class A&#123;</span><br><span class="line">private:</span><br><span class="line">	int i;</span><br><span class="line">	int j;</span><br><span class="line">public:</span><br><span class="line">	A()&#x2F;&#x2F;默认构造函数 </span><br><span class="line">	&#123;cout&lt;&lt;&quot;	A()&quot;&lt;&lt;endl;&#125;	</span><br><span class="line">	A(const A &amp;)&#x2F;&#x2F;拷贝构造函数 </span><br><span class="line">	&#123;cout&lt;&lt;&quot;	A(const A&amp;)&quot;&lt;&lt;endl;&#125;</span><br><span class="line">	A&amp; operator &#x3D;(const A &amp;)&#x2F;&#x2F;拷贝赋值操作符</span><br><span class="line">	&#123;cout&lt;&lt;&quot;	A &amp;operator &#x3D;(const A &amp;)&quot;&lt;&lt;endl;&#125;</span><br><span class="line">	A(int k)&#x2F;&#x2F;</span><br><span class="line">	&#123;cout&lt;&lt;&quot;	A(int k)&quot;&lt;&lt;endl;&#125; </span><br><span class="line">	A(int k,int m)</span><br><span class="line">	&#123;cout&lt;&lt;&quot;	A(int k,int m)&quot;&lt;&lt;endl;&#125;</span><br><span class="line">&#125;; </span><br><span class="line">A func(A temp)&#123;</span><br><span class="line">	return temp;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	cout&lt;&lt;&quot;p1:&quot;&lt;&lt;endl; </span><br><span class="line">		A p1;&#x2F;&#x2F;默认初始化 </span><br><span class="line">	cout&lt;&lt;&quot;p2:&quot;&lt;&lt;endl;</span><br><span class="line">		A p2(1);&#x2F;&#x2F;直接初始化 </span><br><span class="line">	cout&lt;&lt;&quot;p3:&quot;&lt;&lt;endl;</span><br><span class="line">		A p3(1,2);&#x2F;&#x2F;直接初始化</span><br><span class="line">	cout&lt;&lt;&quot;p4:&quot;&lt;&lt;endl;</span><br><span class="line">		A p4&#x3D;1;&#x2F;&#x2F;被编译器优化为A p4(1),直接初始化 </span><br><span class="line">	cout&lt;&lt;&quot;p5:&quot;&lt;&lt;endl;</span><br><span class="line">		A p5(p1);&#x2F;&#x2F;拷贝初始化</span><br><span class="line">	cout&lt;&lt;&quot;p6:&quot;&lt;&lt;endl;</span><br><span class="line">		A p6&#x3D;p1;&#x2F;&#x2F;仍然时拷贝初始化，虽然使用了&#x3D;</span><br><span class="line">	cout&lt;&lt;&quot;p7:&quot;&lt;&lt;endl;</span><br><span class="line">		A p7;&#x2F;&#x2F;先默认初始化</span><br><span class="line">		p7&#x3D;p1;&#x2F;&#x2F;使用了拷贝赋值运算符，是赋值 </span><br><span class="line">	cout&lt;&lt;&quot;p8:&quot;&lt;&lt;endl;</span><br><span class="line">		A p8;&#x2F;&#x2F;默认初始化 </span><br><span class="line">		p8&#x3D;func(p1);&#x2F;&#x2F;较复杂下面分析 </span><br><span class="line">return 0 ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>得到运行结果</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">p1:</span><br><span class="line">        A()&#x2F;&#x2F;默认初始化 </span><br><span class="line">p2:</span><br><span class="line">        A(int k)&#x2F;&#x2F;直接初始化 </span><br><span class="line">p3:</span><br><span class="line">        A(int k,int m)&#x2F;&#x2F;直接初始化</span><br><span class="line">p4:</span><br><span class="line">        A(int k)&#x2F;&#x2F;被编译器优化为A p4(1),直接初始化 </span><br><span class="line">p5:</span><br><span class="line">        A(const A&amp;)&#x2F;&#x2F;拷贝初始化</span><br><span class="line">p6:</span><br><span class="line">        A(const A&amp;)&#x2F;&#x2F;仍然时拷贝初始化，虽然使用了&#x3D;</span><br><span class="line">p7:</span><br><span class="line">        A()&#x2F;&#x2F;先默认初始化</span><br><span class="line">        A &amp;operator &#x3D;(const A &amp;)&#x2F;&#x2F;使用了拷贝赋值运算符，是赋值 </span><br><span class="line">p8:</span><br><span class="line">        A()&#x2F;&#x2F;先默认初始化</span><br><span class="line">        A(const A&amp;)&#x2F;&#x2F;将一个对象作为实参传递给一个非引用类型的形参，发生拷贝初始化，将temp拷贝初始化为p1</span><br><span class="line">        A(const A&amp;)&#x2F;&#x2F;从一个返回类型为非引用类型的函数返回一个对象，当func函数结束时要将返回值拷贝到临时对象，执行拷贝初始化</span><br><span class="line">        A &amp;operator &#x3D;(const A &amp;)&#x2F;&#x2F;将临时对象通过拷贝赋值运算符赋值给p8</span><br><span class="line">		&#x2F;&#x2F;注意这个时候有可能会被编译器优化！</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>语法</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ const关键字</title>
    <url>/C-C/const%E5%85%B3%E9%94%AE%E5%AD%97/</url>
    <content><![CDATA[<p>常类型是指使用类型修饰符const说明的类型，常类型的变量或对象的值是不能被更新的。</p>
<a id="more"></a>
<h2 id="常量指针和指针常量"><a href="#常量指针和指针常量" class="headerlink" title="常量指针和指针常量"></a>常量指针和指针常量</h2><h3 id="1-何为顶层const和底层const"><a href="#1-何为顶层const和底层const" class="headerlink" title="1. 何为顶层const和底层const"></a>1. 何为顶层const和底层const</h3><p>当const修饰指针的时候分为顶层const和底层const，声明指向常量的指针的const是<strong>底层const</strong>(常量指针，不能通过该指针来改变所指的内容)，声明指针常量的const是<strong>顶层const</strong>(指针常量，该指针是一个常量，指向地址不能改变)。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int a&#x3D;1;</span><br><span class="line"></span><br><span class="line">const int *p&#x3D;&amp;a;    &#x2F;&#x2F;该const是底层const，p为常量指针，不能通过*p来修改a的值</span><br><span class="line">&#x2F;&#x2F;*p&#x3D;2; &#x2F;&#x2F;错误，p指向的是常量</span><br><span class="line">p++;    &#x2F;&#x2F;正确，可以改变p所指的地址</span><br><span class="line"></span><br><span class="line">int *const q&#x3D;&amp;a;    &#x2F;&#x2F;该const是顶层const，q为指针常量，不能修改q指向的地址</span><br><span class="line">*q&#x3D;3;   &#x2F;&#x2F;正确，可以通过*q来改变a的值</span><br><span class="line">&#x2F;&#x2F;q++;  &#x2F;&#x2F;错误，不能改变q指向的地址</span><br><span class="line"></span><br><span class="line">const int *const r&#x3D;&amp;a;  &#x2F;&#x2F;r为常量指针常量，第一个const是底层const，第二个const是顶层const</span><br></pre></td></tr></table></figure>
<p><strong>注意</strong>：指向“常量”的指针不代表它所指向的内容一定是常量，只是代表不能通过解引用符（操作符*）来改变它所指向的内容。例如上面可以直接通过a=2赋值改变a的值</p>
<h3 id="2-如何区分底层const和顶层const"><a href="#2-如何区分底层const和顶层const" class="headerlink" title="2. 如何区分底层const和顶层const"></a>2. 如何区分底层const和顶层const</h3><p>const只对它左边的东西起作用，唯一的例外就是const本身就是最左边的修饰符，那么它才会对右边的东西起作用。const int *q=&amp;a和int const *q=&amp;a是一样的。即<strong>const在*右边时是顶层cosnt，此时指针是常量，const在*左边的时候是底层const，此时指针指向常量</strong>。</p>
<h3 id="3-区分底层const和顶层const的作用"><a href="#3-区分底层const和顶层const的作用" class="headerlink" title="3. 区分底层const和顶层const的作用"></a>3. 区分底层const和顶层const的作用</h3><ol>
<li><p>执行对象拷贝时有限制，常量的底层const不能赋值给非底层的const。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int a&#x3D;1;</span><br><span class="line">const int *p&#x3D;&amp;a;	&#x2F;&#x2F;p为底层const的指针</span><br><span class="line">&#x2F;&#x2F;int *const q&#x3D;p;	&#x2F;&#x2F;错误，不能将底层const指针赋值给非底层const指针 </span><br><span class="line">const int *r&#x3D;p;	&#x2F;&#x2F;正确，可以将底层const指针赋值给底层const指针 </span><br><span class="line"></span><br><span class="line">int *const m&#x3D;&amp;a;    &#x2F;&#x2F;顶层const</span><br><span class="line">const int *n&#x3D;m; &#x2F;&#x2F;正确，可以将顶层const赋值给底层const</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用命名的强制类型转换函数const_cast时，需要能够分辨底层const和顶层const，因为const_cast只能改变运算对象的底层const。</p>
</li>
</ol>
<h2 id="常量对象和常量成员函数"><a href="#常量对象和常量成员函数" class="headerlink" title="常量对象和常量成员函数"></a>常量对象和常量成员函数</h2><h3 id="1-常量对象"><a href="#1-常量对象" class="headerlink" title="1. 常量对象"></a>1. 常量对象</h3><p>C++语言中，在定义某个类的对象时，若在整个说明语句前或者在对象名前面加一个关键字const就可以把它定义为<strong>常量对象</strong>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;classname&gt; const A</span><br><span class="line">const &lt;classname&gt; A</span><br></pre></td></tr></table></figure>
<p>C++不允许在常量对象上调用非常量成员函数，同时不允许声明常量的成员函数修改对象。</p>
<h3 id="2-常量成员函数"><a href="#2-常量成员函数" class="headerlink" title="2. 常量成员函数"></a>2. 常量成员函数</h3><p>常量函数是C++对常量的一个扩展，它很好的确保了C++中类的封装性。在C++中，为了防止类的数据成员被非法访问，将类的成员函数分成了两类，一类是<strong>常量成员函数</strong>（观察者）；另一类是<strong>非常量成员函数</strong>（变异者）。在一个函数的签名后面加上关键字const后该函数就成了常量函数。对于常量函数，最关键的不同是编译器不允许其修改类的数据成员。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class A</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">	A():i(0)&#123;	cout&lt;&lt;&quot;A::A()&quot;&lt;&lt;endl;&#125;</span><br><span class="line">	~A()&#123;	cout&lt;&lt;&quot;A::~A()&quot;&lt;&lt;endl;&#125;</span><br><span class="line">    void read() const</span><br><span class="line">    &#123;	cout&lt;&lt;&quot;A::read(),now i&#x3D;&quot;&lt;&lt;i&lt;&lt;endl;&#125; &#x2F;&#x2F;常量成员函数</span><br><span class="line">    void change()</span><br><span class="line">    &#123;i&#x3D;1;	cout&lt;&lt;&quot;A::change(),now i&#x3D;&quot;&lt;&lt;i&lt;&lt;endl;&#125;  &#x2F;&#x2F;非常量成员函数  </span><br><span class="line">private:</span><br><span class="line"></span><br><span class="line">    int i;</span><br><span class="line"></span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure>

<p> 由于常量对象的状态不允许被修改，因此，通过<strong>常量对象调用非常量函数</strong>时将会产生语法错误。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">A m;    &#x2F;&#x2F;非常量对象</span><br><span class="line">m.read();   &#x2F;&#x2F;正确，非常量对象可以调用常量函数</span><br><span class="line">m.change(); &#x2F;&#x2F;正确，非常量对象可以调用非常量函数</span><br><span class="line"></span><br><span class="line">const A n&#x3D;m;    &#x2F;&#x2F;常量对象</span><br><span class="line">n.read();   &#x2F;&#x2F;正确，常量对象只能调用常量函数，因为不希望修改对象状态</span><br><span class="line">&#x2F;&#x2F;n.change();   &#x2F;&#x2F;错误，常量对象的状态不能被修改，而非常量函数存在修改对象状态的**可能**</span><br></pre></td></tr></table></figure>

<p>每个成员函数都有一个隐含的指向对象本身的this指针。而常量函数则包含一个this的常量指针。例如对上面的函数:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void read(const A*this) const;</span><br><span class="line">void change(A*this);</span><br></pre></td></tr></table></figure>

<p>对于常量函数，我们不能通过this指针去修改对象对应的内存块。但是这仅仅是编译器的限制，我们仍然可以绕过编译器的限制，去改变对象的状态。例如将read()改为如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void read() const</span><br><span class="line">&#123;</span><br><span class="line">    A* ptr  &#x3D;   (A*)this;   </span><br><span class="line">    ptr-&gt;i&#x3D;1;</span><br><span class="line">    cout&lt;&lt;&quot;A::read(),now i&#x3D;&quot;&lt;&lt;i&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如此就<strong>可以通过常量函数修改对象的成员</strong>。但是最好不要这样去使用。</p>
<h3 id="3-常量成员函数的重载问题"><a href="#3-常量成员函数的重载问题" class="headerlink" title="3. 常量成员函数的重载问题"></a>3. 常量成员函数的重载问题</h3><p>对于下面的类中的func函数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class A</span><br><span class="line">&#123;</span><br><span class="line">private:</span><br><span class="line">    &#x2F;*...*&#x2F;</span><br><span class="line">public:</span><br><span class="line">    void func() const;</span><br><span class="line">    void func();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对第一个func()函数，隐藏的形参为func(<strong>const A* this</strong>),而第二个func()函数形参为func(<strong>A * this</strong>),二者形参不同故构成了函数的重载，是允许的。存在同名同参数和返回值的常量函数和非常量函数时，具体调用哪个函数是根据调用对象是常量对像还是非常量对象来决定的。<strong>常量对象调用常量成员；非常量对象调用非常量的成员</strong>。     </p>
]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>语法</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ 内联(inline)函数</title>
    <url>/C-C/%E5%86%85%E8%81%94-inline-%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<p>inline是C++关键字，在函数声明或定义中，函数返回类型前加上关键字inline，即可以把函数指定为内联函数。</p>
<a id="more"></a>

<p>在c/c++中，为了解决一些频繁调用的小函数大量消耗栈空间的问题，特别的引入了inline修饰符，表示为内联函数。内联函数实质是在调用点将函数展开，从而减少了对堆栈的操作（在堆栈中调用函数较为复杂，直接展开为代码运行效率更高）。</p>
<p>内联函数牺牲了空间但是降低了调用函数时的额外开销，以空间换时间，在大部分情况下时值得的。</p>
<h3 id="内联函数的使用方法"><a href="#内联函数的使用方法" class="headerlink" title="内联函数的使用方法"></a>内联函数的使用方法</h3><p>在class之外，多一个inline修饰符。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class A&#123;</span><br><span class="line">private:</span><br><span class="line">    &#x2F;*...*&#x2F;</span><br><span class="line">public:</span><br><span class="line">    &#x2F;*...*&#x2F;</span><br><span class="line">    int add(int x,int y) &#123;return x+y;&#125;    </span><br><span class="line">    &#x2F;*...*&#x2F;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;*</span><br><span class="line">如果在类中未给出成员函数定义，而又想内联该函数的话，那在类外要加上inline，否则就认为不是内联的</span><br><span class="line">*&#x2F;</span><br><span class="line">inline int A::add(int x,int y)&#123;</span><br><span class="line">    &#x2F;*...*&#x2F;</span><br><span class="line">&#125;</span><br><span class="line">inline int add1(int x,int y)&#123;</span><br><span class="line">    &#x2F;*...*&#x2F;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在class之内定义的函数是自动内联的。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class A&#123;</span><br><span class="line">private:</span><br><span class="line">    &#x2F;*...*&#x2F;</span><br><span class="line">public:</span><br><span class="line">    &#x2F;*...*&#x2F;</span><br><span class="line">    int add(int x,int y) &#123;return x+y;&#125;    </span><br><span class="line">    &#x2F;*...*&#x2F;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="内联函数的使用规则"><a href="#内联函数的使用规则" class="headerlink" title="内联函数的使用规则"></a>内联函数的使用规则</h3><ol>
<li><p>inline说明对编译器来说只是一种建议，编译器可以选择忽略这个建议。对于过大的函数，编译器会忽略inline。</p>
</li>
<li><p>关键字inline 必须与<strong>函数定义体放在一起</strong>才能使函数成为内联，仅将inline 放在函数声明前面<strong>不起任何作用</strong>,inline函数实质上是一种<strong>声明</strong>，最好直接将内联函数定义一起放在.h文件中。</p>
</li>
</ol>
<h3 id="使用inline的时机"><a href="#使用inline的时机" class="headerlink" title="使用inline的时机"></a>使用inline的时机</h3><p>代码短小（例如只有2、3行）且多次调用。</p>
<p>若函数较大或有递归调用(Recursive functions)则不使用inline。</p>
<h3 id="inline函数与宏函数的差异"><a href="#inline函数与宏函数的差异" class="headerlink" title="inline函数与宏函数的差异"></a>inline函数与宏函数的差异</h3><p>宏</p>
<ol>
<li><p>宏调用是通过简单文本替换来实现的，不会对参数进行类型检查。</p>
</li>
<li><p>宏的使用是预处理器直接对宏代码进行调用，没有参数压栈、生成相应汇编代码、返回参数等时间花费。</p>
</li>
<li><p>宏可能会产生意想不到的边缘效应，很容易出错，要非常小心优先级的变动。</p>
</li>
</ol>
<p>内联</p>
<ol>
<li><p>inline 对编译器来说是一种请求，而不是命令。</p>
</li>
<li><p>C++中的内联机制既具备宏代码的效率，又增加了安全性，可以自由操作类的数据成员，而宏代码无法操作类的私有成员。</p>
</li>
</ol>
<p>例如对于下面代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#define add1(x,y)	((x)+(y)) &#x2F;&#x2F;宏定义</span><br><span class="line">using namespace std;</span><br><span class="line">inline int add2(int x,int y)&#123; &#x2F;&#x2F;内联</span><br><span class="line">	return x+y;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	double a&#x3D;1.0,b&#x3D;2.0;</span><br><span class="line">	printf(&quot; %d \n&quot;,add1(a,b));</span><br><span class="line">	printf(&quot; %d \n&quot;,add2(a,b));</span><br><span class="line">return 0 ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>得到结果</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0&#x2F;&#x2F;宏没有对类型检测</span><br><span class="line">3&#x2F;&#x2F;inline进行了强制类型转化</span><br></pre></td></tr></table></figure>
<p>因而建议在c++中用inline函数代替宏函数</p>
]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>语法</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ new和delete</title>
    <url>/C-C/c++%E4%B8%AD%E7%9A%84new%E5%92%8Cdelete/</url>
    <content><![CDATA[<p>在c++中堆内存的分配与释放是通过new和delete来实现的，new和delete是两个操作符，无需头文件支持</p>
<a id="more"></a>
<h2 id="new"><a href="#new" class="headerlink" title="new"></a>new</h2><h3 id="new运算符"><a href="#new运算符" class="headerlink" title="new运算符"></a>new运算符</h3><p>new运算符返回指向所分配类型对象的指针，new运算符首先<strong>向系统堆区申请足够的储存空间</strong>，如果申请成功，则再<strong>调用相应的默认构造函数</strong>，然后返回申请空间的地址</p>
<h3 id="new的使用方法"><a href="#new的使用方法" class="headerlink" title="new的使用方法"></a>new的使用方法</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int *p&#x3D; new int ;&#x2F;&#x2F;申请int</span><br><span class="line">int *psome&#x3D; new int[10];&#x2F;&#x2F;申请int数组</span><br><span class="line">A *q&#x3D; new A;&#x2F;&#x2F;申请自定义类型</span><br><span class="line">A *qsome&#x3D; new A[10];&#x2F;&#x2F;申请自定义类型数组</span><br></pre></td></tr></table></figure>
<h2 id="delete"><a href="#delete" class="headerlink" title="delete"></a>delete</h2><h3 id="delete运算符"><a href="#delete运算符" class="headerlink" title="delete运算符"></a>delete运算符</h3><p>delete运算符首先<strong>执行默认析构函数</strong>，然后再<strong>回收分配的空间</strong></p>
<h3 id="delete的使用方法"><a href="#delete的使用方法" class="headerlink" title="delete的使用方法"></a>delete的使用方法</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">delete p;&#x2F;&#x2F;释放int</span><br><span class="line">delete []psome;&#x2F;&#x2F;释放int数组</span><br><span class="line">delete q;&#x2F;&#x2F;释放自定义类型</span><br><span class="line">delete []qsome;&#x2F;&#x2F;释放自定义类型数组</span><br></pre></td></tr></table></figure>
<h3 id="关于delete-ptr和delete-ptr的差别"><a href="#关于delete-ptr和delete-ptr的差别" class="headerlink" title="关于delete ptr和delete []ptr的差别"></a>关于delete ptr和delete []ptr的差别</h3><p>回归到new和delete上，当我们调用operator new[]/new来分配数组对象时，编译器时系统内部会增加4或者8字节的分配空间用来保存所分配的数组对象的数量,可以理解为下面这对pair<br>| 储存分配空间的字节数 | 分配空间的地址 |<br>| -|-|<br>|           4|0xabcd<br>例如分配以下空间</p>
<p><code>A *psome =new A[10];</code></p>
<p>此时如果使用delete psome,则只会调用一次析构函数，但是会收回所有分配的空间；而使用delete []psome，则会依次调用psome[0]-psome[9]的析构函数，然后再收回所有的分配空间</p>
<p>例如对于下面的代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int count&#x3D;0;</span><br><span class="line">class A&#123;</span><br><span class="line">public:</span><br><span class="line">	int i;</span><br><span class="line">	A();</span><br><span class="line">	~A(); </span><br><span class="line">&#125;; </span><br><span class="line">A::A()&#123;&#x2F;&#x2F;构造函数</span><br><span class="line">	i&#x3D;count++;</span><br><span class="line">	cout&lt;&lt;&quot;A::A() i&#x3D;&quot;&lt;&lt;i&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">A::~A()&#123;&#x2F;&#x2F;析构函数</span><br><span class="line">	cout&lt;&lt;&quot;A::~A() i&#x3D;&quot;&lt;&lt;i&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	A *psome&#x3D; new A[10];</span><br><span class="line">	delete psome;</span><br><span class="line">	&#x2F;&#x2F;delete []psome;</span><br><span class="line">    return 0 ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行得到结果如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">A::A() i&#x3D;0&#x2F;&#x2F;依次执行构造函数</span><br><span class="line">A::A() i&#x3D;1</span><br><span class="line">A::A() i&#x3D;2</span><br><span class="line">A::A() i&#x3D;3</span><br><span class="line">A::A() i&#x3D;4</span><br><span class="line">A::A() i&#x3D;5</span><br><span class="line">A::A() i&#x3D;6</span><br><span class="line">A::A() i&#x3D;7</span><br><span class="line">A::A() i&#x3D;8</span><br><span class="line">A::A() i&#x3D;9</span><br><span class="line">A::~A() i&#x3D;0&#x2F;&#x2F;只执行依次析构函数，但空间全部回收</span><br></pre></td></tr></table></figure>
<p>可以看到只执行了依次析构函数，因为对于delete而言psome所指对象只有一个对象</p>
<p>如果执行的是delete []psome,得到结果如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">A::A() i&#x3D;0</span><br><span class="line">A::A() i&#x3D;1</span><br><span class="line">A::A() i&#x3D;2</span><br><span class="line">A::A() i&#x3D;3</span><br><span class="line">A::A() i&#x3D;4</span><br><span class="line">A::A() i&#x3D;5</span><br><span class="line">A::A() i&#x3D;6</span><br><span class="line">A::A() i&#x3D;7</span><br><span class="line">A::A() i&#x3D;8</span><br><span class="line">A::A() i&#x3D;9&#x2F;&#x2F;执行10次构造函数</span><br><span class="line">A::~A() i&#x3D;9</span><br><span class="line">A::~A() i&#x3D;8</span><br><span class="line">A::~A() i&#x3D;7</span><br><span class="line">A::~A() i&#x3D;6</span><br><span class="line">A::~A() i&#x3D;5</span><br><span class="line">A::~A() i&#x3D;4</span><br><span class="line">A::~A() i&#x3D;3</span><br><span class="line">A::~A() i&#x3D;2</span><br><span class="line">A::~A() i&#x3D;1</span><br><span class="line">A::~A() i&#x3D;0&#x2F;&#x2F;执行10次析构函数</span><br></pre></td></tr></table></figure>
<p>可以看到执行了10次析构函数，并且是从最后一个元素开始向前执行的，此时delete知道psome所指地址有多个对象，会通过上面的pair计算要执行析构函数的次数并依次执行</p>
<p>因此就结论而言，new/delete 、new []/delete[] 最好要配对使用</p>
<h2 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h2><p>1.不要使用delete去释放没有new的内存</p>
<p>2.不要重复delete</p>
<p>3.delete[]和new[]配套使用 ，delete和new配套使用</p>
<p>4.delete空指针是安全的（体现完备性）</p>
]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>语法</tag>
      </tags>
  </entry>
  <entry>
    <title>markdown基本语法</title>
    <url>/%E6%9D%82/%E6%B5%8B%E8%AF%95%E6%96%87%E7%AB%A0/</url>
    <content><![CDATA[<p>用于练习markdown语法与相关操作</p>
<a id="more"></a>
<h2 id="0-让文字显示摘要"><a href="#0-让文字显示摘要" class="headerlink" title="0.让文字显示摘要"></a>0.让文字显示摘要</h2><p>在MD格式文章正文插入&lt;!-- more --&gt;即可，这样只会显示之前的内容</p>
<h2 id="1-标题控制"><a href="#1-标题控制" class="headerlink" title="1.标题控制"></a>1.标题控制</h2><p>利用#号控制标题</p>
<p>1.#一级标题</p>
<h1 id="一级标题"><a href="#一级标题" class="headerlink" title="一级标题"></a>一级标题</h1><p>2.##二级标题  </p>
<h2 id="二级标题"><a href="#二级标题" class="headerlink" title="二级标题"></a>二级标题</h2><p>3.###三级标题  </p>
<h3 id="三级标题"><a href="#三级标题" class="headerlink" title="三级标题"></a>三级标题</h3><p>4.####四级标题  </p>
<h4 id="四级标题"><a href="#四级标题" class="headerlink" title="四级标题"></a>四级标题</h4><p>5.#####五级标题  </p>
<h5 id="五级标题"><a href="#五级标题" class="headerlink" title="五级标题"></a>五级标题</h5><p>6.######六级标题</p>
<h6 id="六级标题"><a href="#六级标题" class="headerlink" title="六级标题"></a>六级标题</h6><h2 id="2-段落分行"><a href="#2-段落分行" class="headerlink" title="2.段落分行"></a>2.段落分行</h2><p>只需要在两个段落间加一个空行，即回车两次</p>
<h2 id="3-区块引用"><a href="#3-区块引用" class="headerlink" title="3.区块引用"></a>3.区块引用</h2><blockquote>
<p>在引用的区块前加’&gt;’即可</p>
</blockquote>
<h2 id="4-超链接"><a href="#4-超链接" class="headerlink" title="4.超链接"></a>4.超链接</h2><p>[超链接显示文字](<a href="http://www.baidu.com" target="_blank" rel="noopener">http://www.baidu.com</a> “超链接title”)</p>
<p><a href="http://www.baidu.com" target="_blank" rel="noopener" title="超链接title">超链接显示文字</a></p>
<p>其中超链接title为浮动提示文字，懒狗不写</p>
<h2 id="5-图片显示"><a href="#5-图片显示" class="headerlink" title="5.图片显示"></a>5.图片显示</h2><p>![百度logo](<a href="https://www.baidu.com/img/bd_logo1.png?where=super" target="_blank" rel="noopener">https://www.baidu.com/img/bd_logo1.png?where=super</a>)</p>
<p><img src="https://www.baidu.com/img/bd_logo1.png?where=super" alt="百度logo"></p>
<h2 id="6-无序列表"><a href="#6-无序列表" class="headerlink" title="6.无序列表"></a>6.无序列表</h2><p>无序列表使用<em>、+、-标识，但是一般使用</em>来标识无序列表</p>
<p>* 无序列表</p>
<p>+ 无序列表</p>
<p>- 无序列表</p>
<p>显示</p>
<ul>
<li>无序列表</li>
</ul>
<ul>
<li>无序列表</li>
</ul>
<ul>
<li>无序列表<h2 id="7-有序列表"><a href="#7-有序列表" class="headerlink" title="7.有序列表"></a>7.有序列表</h2>用数字 + ‘.’ 标识</li>
</ul>
<p>1.有序列表1</p>
<p>   1.有序列表2</p>
<p>2.有序列表3</p>
<p>显示为</p>
<ol>
<li>有序列表1<ol>
<li>有序列表2</li>
</ol>
</li>
<li>有序列表3    </li>
</ol>
<h2 id="8-分隔线"><a href="#8-分隔线" class="headerlink" title="8.分隔线"></a>8.分隔线</h2><p>***</p>
<p>显示如下</p>
<hr>
<h2 id="9-字体修改"><a href="#9-字体修改" class="headerlink" title="9.字体修改"></a>9.字体修改</h2><p>*斜体*</p>
<p><em>斜体</em></p>
<p>**加粗**</p>
<p><strong>加粗</strong></p>
<p>***斜体加粗***</p>
<p><strong><em>斜体加粗</em></strong></p>
<h2 id="10-代码块"><a href="#10-代码块" class="headerlink" title="10.代码块"></a>10.代码块</h2><p>利用单个反引号`（在esc下面） 包裹代码</p>
<p>`int a=1 `</p>
<p><code>int a=1</code></p>
<p>处理多行代码是通过三个反引号包裹代码</p>
<p>```</p>
<p> int a=1;</p>
<p> int b=2;</p>
<p> int c=3;</p>
<p>```</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">int a&#x3D;1;</span><br><span class="line">int b&#x3D;2;</span><br><span class="line">int c&#x3D;3;</span><br></pre></td></tr></table></figure>

<h2 id="11-表格"><a href="#11-表格" class="headerlink" title="11.表格"></a>11.表格</h2><p>| a | b | c |</p>
<p>|—|—|—|</p>
<p>|1  |2  |3  |</p>
<p>|4  |5  |6  |</p>
<p>|7  |8  |9  |</p>
<table>
<thead>
<tr>
<th>a</th>
<th>b</th>
<th>c</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>2</td>
<td>3</td>
</tr>
<tr>
<td>4</td>
<td>5</td>
<td>6</td>
</tr>
<tr>
<td>7</td>
<td>8</td>
<td>9</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>杂</category>
      </categories>
      <tags>
        <tag>语法</tag>
        <tag>markdown</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/%E6%9D%82/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<a id="more"></a>

<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>
]]></content>
      <categories>
        <category>杂</category>
      </categories>
      <tags>
        <tag>Hello World</tag>
      </tags>
  </entry>
</search>
